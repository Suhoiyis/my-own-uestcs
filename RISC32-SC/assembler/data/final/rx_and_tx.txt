# t0 UART 基地址 (0x30000000)
# t1 临时状态值
# s1: RAM 缓冲区基地址 (0x10000000)
# s0: 发送数据指针
# a7: 计数器
# 先收被除数，再收除数
# 先发商，再发余数
# a1: 被除数 (Dividend) 0x10000000
# a2: 除数 (Divisor) 0x10000004
# a3: 商 (Quotient) 0x10000008
# a4: 余数 (Remainder) 0x1000000C
# a0: 临时数据 (用于UART收发)

# 初始化
lui   t0, 0x30000       # t0 = 0x30000000 (UART 基地址)
addi  t1, zero, 3       # t1 = 3 (二进制...0011)
sw    t1, 0(t0)         # 将 3 写入 0x30000000 (UART_CTRL)
                        # 使能第0位(发送)和第1位(接收)

# (设置数据缓冲区指针 s1, 假设存在 0x10000000)
lui   s1, 0x10000       # s1 = 0x10000000

addi  a7, zero, 2       # 初始化计数器 a7 = 2 (接收2个数据)

# 外循环 (数据循环)
rx_loop_start:
    beq   a7, zero, rx_loop_end # 如果计数器为0, 说明都收完了, 跳转到结尾

# 内层循环 等待
wait_rx:
    lw    t1, 4(t0)         # 从地址 tO+4（Ox30000004）加载 UART_STATUS 的值到 t1
    andi  t1, t1, 2         # 按位与，，仅保留 t1的第1位（接收完成标志位，1表示接收完成，0表示正在接收）（2的二进制是000010）其他位归零
    beq   t1, zero, wait_rx # t1 等于θ（即接收未完成），则跳转回 wait_rx 继续等



# 置零
sw  zero, 4(t0)         # 将 0 写入 UART_STATUS,没接收到新数据。。。。。

# 接收
lw    a0, 16(t0)        # 从地址 t0+16（0x30000010），即 UART_RXDATA，读取数据到 aθ

# 存储数据并更新外循环
    sw    a0, 0(s1)         # 将 a0 中的数据（32位）存入 s1 指向的内存
    addi  s1, s1, 4         # 缓冲区指针 s1 指向下一个空位
    addi  a7, a7, -1        # 计数器 a7 减 1
    jal   zero, rx_loop_start # 无条件跳回外层循环的起点, 接收下一个

rx_loop_end:
    # (数据接收完毕, 存储在 0x10000000, 1中)
    # 此时, "被除数" 存在 0x10000000
    # "除数" 存在 0x10000004
    # s1 指针现在指向 0x10000008

    lui   t1, 0x10000       # t1 = 0x10000000 (用于加载)
    lw    a1, 0(t1)         # 加载 "被除数" 到 a1 (32位)
    lw    a2, 4(t1)         # 加载 "除数"  到 a2

    div   a3, a1, a2        # a3 = 商 (a1 / a2)
    rem   a4, a1, a2        # a4 = 余数 (a1 % a2)

sw    a3, 0(s1)         #  将 32位商 存入 0x10000008
addi  s1, s1, 4         #  s1 指向 0x1000000C
sw    a4, 0(s1)         # 将 32位余数 存入 0x1000000C


lui   s0, 0x10000       # s0 = 0x10000000
addi  s0, s0, 8         # s0 = 0x10000008 (指向"商"a3)
addi  a7, zero, 2       # 重置计数器 a7 = 2 (发送2个数据)

tx_loop_start:
    beq   a7, zero, tx_loop_end # 计数器为0, 则结束
    lw   a0, 0(s0)         # 从 s0 指向的地址加载数据（商、余数）到 a0

# 内循环 等待
wait_tx:
    lw    t1, 4(t0)         # 从地址t0+4（0x30000004）加载UART_STATUS的值到t1
    andi  t1, t1, 1         # 按位与，，只保留t1的第θ位（发送忙标志位，1表示正在发送，日为空闲），其他位归零
    bne   t1, zero, wait_tx # t1 不等于θ（即忙标志位为1，正在发送），则跳转回 wait_tx 继续等待

# 发送
sw    a0, 12(t0)        # 将 a0 写入 0x3000000c (TXDATA)

# 置1
    ori    t1, t1, 1        # 设置 bit 0 为 1
    sw     t1, 4(t0)        # 写回 UART_STATUS

# 更新外循环
    addi  s0, s0, 4         # 数据指针+1
    addi  a7, a7, -1        # 计数器-1
    jal   zero, tx_loop_start # 跳回外层循环

tx_loop_end:
    # .. 发送完毕
    # jal   zero, tx_loop_end
