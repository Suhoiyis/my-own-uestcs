# -------------------------------------------------------------------
# 纯汇编版流水灯程序 (RV32I)
# 逻辑完全对应 led.c
# -------------------------------------------------------------------

# ===================================================================
# 常量定义
# ===================================================================
# LED 基地址: 0x40000000
# DELAY_COUNT: 100000 (0x186A0)
# ===================================================================

start_kernel:
    # --- 初始化 ---
    # s0 保存 LED 基地址 0x40000000
    lui     s0, 0x40000         # s0 = 0x40000 << 12 = 0x40000000

main_loop:
    # ---------------------------------------------------------------
    # 状态 1: LED = 0x01 (0000 0001)
    # ---------------------------------------------------------------
    addi    t0, zero, 1         # t0 = 1
    sb      t0, 0(s0)           # 写入 0x40000000 (LED_REG = 0x01)
    jal     ra, delay_func      # 调用延迟函数

    # ---------------------------------------------------------------
    # 状态 2: LED = 0x02 (0000 0010)
    # ---------------------------------------------------------------
    addi    t0, zero, 2         # t0 = 2
    sb      t0, 0(s0)           # 写入
    jal     ra, delay_func      # 延迟

    # ---------------------------------------------------------------
    # 状态 3: LED = 0x04 (0000 0100)
    # ---------------------------------------------------------------
    addi    t0, zero, 4         # t0 = 4
    sb      t0, 0(s0)
    jal     ra, delay_func

    # ---------------------------------------------------------------
    # 状态 4: LED = 0x08 (0000 1000)
    # ---------------------------------------------------------------
    addi    t0, zero, 8         # t0 = 8
    sb      t0, 0(s0)
    jal     ra, delay_func

    # ---------------------------------------------------------------
    # 状态 5: LED = 0x10 (0001 0000)
    # ---------------------------------------------------------------
    addi    t0, zero, 16        # t0 = 16 (0x10)
    sb      t0, 0(s0)
    jal     ra, delay_func

    # ---------------------------------------------------------------
    # 状态 6: LED = 0x20 (0010 0000)
    # ---------------------------------------------------------------
    addi    t0, zero, 32        # t0 = 32 (0x20)
    sb      t0, 0(s0)
    jal     ra, delay_func

    # ---------------------------------------------------------------
    # 状态 7: LED = 0x40 (0100 0000)
    # ---------------------------------------------------------------
    addi    t0, zero, 64        # t0 = 64 (0x40)
    sb      t0, 0(s0)
    jal     ra, delay_func

    # ---------------------------------------------------------------
    # 状态 8: LED = 0x80 (1000 0000)
    # ---------------------------------------------------------------
    addi    t0, zero, 128       # t0 = 128 (0x80)
    sb      t0, 0(s0)
    jal     ra, delay_func

    # ---------------------------------------------------------------
    # 循环结束，跳回开始
    # ---------------------------------------------------------------
    jal     zero, main_loop     # 无限循环 while(1) (用 jal zero 替代 j，以适应简易汇编器)


# ===================================================================
# 延迟函数: void simple_delay(long long count)
# 为了简化，我们在汇编里硬编码 count = 100000
# 对应 C 代码中的 for 循环
# ===================================================================
delay_func:
    # 这里的 t1 就是循环计数器 i
    # 我们要加载 100000 (0x186A0) 到 t1
    # 0x186A0 超过了 12位立即数，需要用 lui + addi 组合
    # 0x186A0 分解: 高20位是 0x00018, 低12位是 0x6A0

    lui     t1, 0x00018         # t1 = 0x18000
    addi    t1, t1, 0x6A0       # t1 = 0x186A0 (100000)

delay_loop:
    # 循环体: i--
    addi    t1, t1, -1          # t1 = t1 - 1

    # 判断: if (i != 0) goto delay_loop
    bne     t1, zero, delay_loop

    # 返回: ret
    jalr    zero,  ra, 0
