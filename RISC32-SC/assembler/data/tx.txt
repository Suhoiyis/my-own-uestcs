# t0 UART 基地址 (0x30000000)
# t1 临时状态值
# s0 数据指针 ，指向要发送的第一个数据
# a0 当前要发送的字符
# a7 计数器
# t2 临时寄存器，用于存放 1, 2, 5

lui   t0, 0x30000       # t0 = 0x30000000 (UART 基地址)
addi  t1, zero, 3       # t1 = 3 (二进制..0011)
sw    t1, 0(t0)         # 将 3 写入 0x30000000 (UART_CTRL)
                        # 第0位(发送)和第1位(接收)都为1（使能）

# (设置要发送的数据指针, 假设 第一个数据 存在 0x10000004)
lui   s0, 0x10000       # s0 = 0x10000000
addi  s0, s0, 4         # s0 = 0x10000004


addi  t2, zero, 1       # t2 = 1
sb    t2, 0(s0)         # 将 1 存入内存地址 0x10000004

addi  t2, zero, 2       # t2 = 2
sb    t2, 1(s0)         # 将 2 存入内存地址 0x10000005

addi  t2, zero, 5       # t2 = 5
sb    t2, 2(s0)         # 将 5 存入内存地址 0x10000006



addi  a7, zero, 3       # 初始化计数器 a7 = 3 (发送3个字符)


tx_loop_start:
    beq   a7, zero, tx_loop_end # 计数器为0, 则结束
    lbu   a0, 0(s0)         # 从 s0 指向的地址加载数据到 a0
                            # 依次加载1 2 5


    wait_tx:
        lw    t1, 4(t0)         # 从地址t0+4（0x30000004）加载UART_STATUS的值到t1
        andi  t1, t1, 1         
        bne   t1, zero, wait_tx 


    sw    a0, 12(t0)        # 将 a0 写入 0x3000000c (TXDATA)
    ori    t1, t1, 1        # 设置 bit 0 为 1
    sw     t1, 4(t0)        # 写回 UART_STATUS

    addi  s0, s0, 1         # 数据指针+1
    addi  a7, a7, -1        # 计数器-1
    jal   zero, tx_loop_start # 跳回外层循环

tx_loop_end:
    # .. 发送完毕
    jal   zero, tx_loop_end # 死循环
