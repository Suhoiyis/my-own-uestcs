
# 01. 硬件扫描键盘

介绍了如何通过纯硬件电路来识别用户按下了哪个键。这是最基础的键盘工作原理。

### 1. 核心目标 (Objective)

键盘的核心任务有两个：

1. **定位**：找出你按下了哪个键（行号和列号）。
    
2. **转换**：把这个物理位置转换成计算机能懂的代码（如 ASCII 码）。
    

### 2. 硬件组成 (Components) —— “四大金刚”

请看 **PPT P5** 的框图，硬件扫描键盘主要由四部分组成 ：

1. **计数器 (Counter)**：它是扫描的动力源。在一个振荡器的推动下，不停地从 0 开始计数（比如从 0 数到 127）。这个数值代表了当前正在“询问”的按键位置。
    
2. **译码器 (Decoder)**：
    
    - **行译码**：负责选中某一行。
        
    - **列译码**：负责选中某一列。
        
    - _作用_：把计数器的数值翻译成具体的行线和列线信号，依次去“点名”每一个按键。
        
3. **键盘矩阵 (Key Matrix)**：这是按键的物理排列（比如 8 行 × 16 列）。每个按键就在行线和列线的交叉点上。
    
4. **符合比较器 (Comparator)**：它是“裁判”。它比较列线的实际输出和列译码的理论输出。
    
    - _原理_：如果某个键被按下了，行线和列线就会导通。此时，比较器会检测到信号变化，输出一个**“锁定信号”**。
        

### 3. 工作流程 (Workflow) —— “地毯式搜索”

这是一个不停循环的过程 ：

1. **扫描**：计数器不停地数数，译码器就不停地依次扫描每一个按键位置（先扫第一行第一列，再第一行第二列……）。
    
2. **按键**：当你按下一个键时，这个位置的行线和列线就接通了。
    
3. **锁定**：当计数器数到你按下的那个键的位置时，比较器发现：“咦？这个位置导通了！”。于是它立刻发出**锁定信号**，让计数器**停止计数**。
    
4. **查表**：此时计数器停住的数值，就是这个按键的**位置码**（扫描码）。硬件拿着这个位置码去查 **ROM**（只读存储器）。
    
5. **输出**：ROM 里存着位置码和 ASCII 码的对应表。查表后，直接输出对应的 **ASCII 码** 给接口。
    

### 🧠 总结

硬件扫描键盘就像一个**不知疲倦的保安**，拿着手电筒（扫描信号）一个房间一个房间（按键）地照。一旦发现某个房间有人（按键按下），立马停下来，查户口本（ROM），把这个人的名字（ASCII 码）报上去。

这种方式的优点是**不占用 CPU 时间**，缺点是硬件电路比较复杂。



# 02. 软件扫描键盘


介绍了一种更节省硬件成本、利用程序逻辑来识别按键的方法。

与硬件扫描不同，这里不再需要复杂的计数器和比较器电路，而是靠 **“轮询程序”** 来干活。课件主要介绍了两种经典的扫描策略。

---

### 一、基本定义 (Definition)

- **核心思想**：通过执行**键盘扫描程序**来识别按键的物理位置（行列号），并将其转换为相应的代码（如 ASCII 码）。
    
- **本质**：用 **CPU 的时间**（或专用微控制器的时间）换取 **接口电路的简化**。
    

---

### 二、策略一：逐行扫描法 (Row-by-Row Scanning) —— “步步为营”

这是最朴素的软件扫描算法（课件 P7-P8）。
![[Pasted image 20251229202224.png]]
#### 1. 硬件连接

键盘矩阵的**行线**接输出口，**列线**接输入口。平时行线都输出高电平，如果有键按下，对应的列线电平会被拉低（假设低电平有效）。

#### 2. 扫描流程 (Scanning Process)

请看 **PPT P8** 的流程图，这是一个**“先粗查，后细查”**的过程：
![[Pasted image 20251229202210.png]]
- **第一步：粗查（有没有人按？）**
    
    - CPU 向**所有行**输出低电平（全 0。
        
    - 读取列线状态。如果列线里有 0，说明**至少有一个键被按下了**。
        
- **第二步：细查（哪一行按的？）**
    
    - CPU 开始循环：
        
        - 先给**第 0 行**送 0（其他行送 1），读列线。如果有 0，说明键在第 0 行。
            
        - 如果没有，给**第 1 行**送 0，读列线……
            
        - 以此类推，直到找到那一行 5。
            
- **第三步：定位与转换**
    
    - 确定了行号和列号，也就确定了按键的物理位置。
        
    - 查表将位置码转换为 **ASCII 码** 6。
        

---

### 三、策略二：行列扫描法 (Matrix Scanning) —— “IBM PC 模式”

这是 PC 键盘所采用的更高效、更智能的方法（课件 P9）。

#### 1. 智能化的硬件结构

它不再由主机的 CPU 直接去扫，而是键盘内部自带了一个 **单片机 (如 8048)** 7。

- **8048 单片机**：负责干扫描的脏活累活。
    
- **主机 CPU**：只负责接收结果。
    

#### 2. 工作过程 (Workflow)

这是一个**分工合作**的过程：

- **键盘内部 (8048 工作)**：
    
    1. **扫描**：8048 控制行线和列线，先逐列扫描，再逐行扫描，迅速锁定按键位置 8。
        
    2. **发码**：获得按键的 **扫描码 (Scan Code)**，并通过**串行线**发送给主机接口 9。
        
- **主机接口 (Interface 工作)**：
    
    - 接收串行数据，拼成并行字节，然后向 CPU 发 **中断请求** 10。
        
- **主机 CPU (Main CPU 工作)**：
    
    - 响应中断，执行键盘中断子程序。
        
    - 从接口读取扫描码，查表转换为 **ASCII 码**，存入键盘缓冲区供用户程序使用 11。
        

---

### 🧠 总结：两种软件扫描的对比

|**特性**|**逐行扫描法 (简易)**|**行列扫描法 (IBM PC)**|
|---|---|---|
|**扫描者**|**主机 CPU** 亲自扫描|键盘内的 **MCU (8048)** 扫描|
|**CPU 负担**|重（CPU 要一直轮询）|**轻**（CPU 只响应中断）|
|**硬件连接**|需要较多并行 I/O 线|仅需几根 **串行线**|
|**适用场景**|嵌入式设备、简单控制器|**现代计算机 (PC)**|

这一节告诉我们：虽然叫“软件扫描”，但为了不累死主 CPU，现代计算机通常把这个“软件”固化在键盘内部的芯片里去执行。