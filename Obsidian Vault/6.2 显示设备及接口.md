
# 1. 概述


### 1. 显示系统的组成 (Composition)

一个完整的显示系统由 **硬件** 和 **软件** 两部分构成。

#### **(1) 硬件部分**

硬件连接链条如下：
![[Pasted image 20251229202419.png]]
CPU $\leftrightarrow$ 接口 $\leftrightarrow$ 控制器 $\leftrightarrow$ 显示器件

- **显示器件**：即我们看到的“屏幕”本身。
    
- **显示适配器 (Display Adapter)**：也就是常说的 **显卡**。
    
    - 它实际上包含了 **接口** 和 **控制器** 两部分。
        
    - 它的作用是连接 CPU 和显示器，负责图像数据的缓存、转换和控制。
        

#### **(2) 软件部分**

- **显示驱动程序**：运行在 CPU 上，负责翻译操作系统或应用程序的绘图指令，控制显卡工作。
    

---

### 2. 显示器件的分类 (Classification of Display Devices)

课件根据 **发光原理** 将屏幕分为两大类 2：

#### **① 发光器件 (Active / Light-emitting)**

- **原理**：主动发光。外加电信号后，器件本身产生光辐射。
    
- **代表**：
    
    - **CRT** (阴极射线管)：老式的大头显示器。
        
    - **PDP** (等离子)。
        
    - **LED** (发光二极管)。
        

#### **② 光调制器件 (Passive / Light-modulating)**

- **原理**：被动发光。它自己不发光，而是通过电信号改变物质的光学特性（透光或反光），来调制背光或环境光。
    
- **代表**：
    
    - **LCD** (液晶显示器)：利用液晶分子的旋转来控制透光率。
        

---

### 3. 本章的学习重点

虽然现在的显示器大多是 LCD 或 OLED，但 **CRT 显示器** 的很多基本原理（如光栅扫描、刷新率、VRAM 映射）是理解现代计算机图形显示技术的**理论基础**。

因此，接下来的课程将重点讨论：

1. **CRT 的成像原理**（电子束怎么画图）。
    
2. **显存 (VRAM) 与屏幕的对应关系**（内存里的 0/1 怎么变成屏幕上的图像）3。


# 2. 显示技术中的相关术语


这一节（**课件 P14-P15**）定义了图形显示领域的“行话”，其中有几组概念非常容易混淆，请重点区分。

#### 1. 图形 vs 图像 (Graphics vs Image)

- **图形 (Graphics)**：指**矢量图**。
    
    - 定义：没有亮暗层次变化的线条图。
        
    - _特点_：由指令生成（如“画一条直线”、“画一个圆”），放大不失真。
        
- **图像 (Image)**：指**位图**。
    
    - 定义：具有亮暗层次（灰度或颜色）的图。
        
    - _特点_：由像素点阵组成，像照片一样。
        

#### 2. 两个关键指标

- **分辨率 (Resolution)**：显示器所能表示的**像素个数**（列数 $\times$ 行数）。分辨率越高，画面越细腻。
    
- **灰度级 (Gray Scale)**：
    
    - 定义：像素点的**亮暗差别**（黑白）或**颜色不同**（彩色。
        
    - _关系_：图形质量 = 分辨率（清晰度）+ 灰度级（色彩丰富度）。
        

#### 3. 刷新 (Refresh) —— “欺骗眼睛的艺术”

- **原理**：电子束打在荧光屏上，光亮会迅速消失。为了让人眼看到稳定的画面，必须不断地重复扫描整个屏幕。
    
- **标准**：刷新频率必须大于 **25Hz**（每秒 25 次）才不会感到闪烁。现代显示器通常选用 **60Hz - 70Hz** 或更高。
    

#### 4. 扫描方式：随机 vs 光栅 (Random vs Raster) —— **⭐ 重点**

这是两种截然不同的画图策略：

- **随机扫描 (Random Scan)**：
    
    - **像“写字”**。电子束像笔一样，指哪打哪，只在有图形的地方画线，不扫描空白处。
        
    - _优点_：画图快，线条清晰（早期雷达、示波器用这个。
        
- **光栅扫描 (Raster Scan)**：
    
    - **像“织布”**。电子束不管画面是什么，都死板地从上到下、从左到右扫遍整个屏幕。
        
    - **方式**：
        
        - **逐行扫描**：一行接一行扫到底（1, 2, 3, 4...）。
            
        - **隔行扫描**（电视技术）：先扫奇数行（1, 3, 5...），再扫偶数行（2, 4, 6...），利用人眼视觉暂留来减少闪烁感。


# 3. CRT显示器的显示方式与常见显示规格


介绍了计算机控制显示器的两种基本模式。

#### 1. 字符/数字方式 (A/N Mode) —— “打字机模式”

- **单位**：以 **字符** 为显示单位 。
    
- **规格描述**：`字符行数 × 列数`。
    
    - _例如_：标准 VGA 文本模式是 **25 行 × 80 列**。这意味着屏幕被切成了 2000 个小格子，每个格子只能放一个字符。
        

#### 2. 图形方式 (APA Mode) —— “画板模式”

- **全称**：All Points Addressable (全点可寻址)。
    
- **单位**：以 **点 (Pixel)** 为显示单位 。
    
- **规格描述**：`每线点数 × 线数`。
    
    - _例如_：**640 × 200** 或 **800 × 600**。你可以控制屏幕上任意一个点的颜色。


# 4. 光栅扫描成象原理


揭秘了 CRT 显示器到底是怎么把电信号变成画面的。

#### 1. CRT 的物理结构

请看 **PPT P17** 的结构图：
![[Pasted image 20251229202621.png]]
- **电子枪**：发射电子束（画笔）。
    
- **偏转系统**：
    
    - **水平偏转线圈**：控制电子束左右跑。
        
    - **垂直偏转线圈**：控制电子束上下跑。
        
- **控制信号**：
    
    - **同步信号**：告诉电子束“什么时候换行”、“什么时候回起点”。
        
    - **视频信号**：控制电子束的“开关”（亮/灭）。
        

#### 2. 光栅的形成 (锯齿波)

电子束怎么走出“之”字形的扫描轨迹？

- 给偏转线圈通入 **锯齿波电流**。
    
    - **水平扫描**：电流慢慢变大（电子束从左移到右），然后瞬间变小（电子束迅速回扫到左边）。
        
    - **垂直扫描**：同理，控制从上到下的移动。
        

#### 3. 像素点的控制 (The Pixel)

屏幕上的每一个点是怎么显示出来的？靠三个因素：

1. **位置**：由水平/垂直 **同步信号** 决定（我在哪？）。
    
2. **亮度**：由 **视频信号** 决定（我是亮还是暗？）。
    
    - 视频信号 = 1 $\rightarrow$ 电子束开 $\rightarrow$ 点亮。
        
    - 视频信号 = 0 $\rightarrow$ 电子束关 $\rightarrow$ 点暗。
        
3. **颜色**：由 **RGB (红绿蓝)** 三基色信号组合决定。
    
    - 例如：`R=1, G=0, B=0` 显示红色；`R=1, G=1, B=1` 显示白色。
        

#### 4. 字符点阵的形成 (Character Generation) —— **⭐ 难点**

在 A/N 模式下，计算机只送出了字符的 **ASCII 码**，屏幕上怎么就出现了“A”这个形状？

- **核心部件**：**字符发生器 (ROM)**。
    
- **原理**：
    
    - ROM 里存好了所有字符的 **点阵图**（比如 7×9 的点阵）。
        
    - **输入**：字符的 ASCII 码 + 当前扫描到的行号。
        
    - **输出**：这一行像素点的亮灭信号（0001000...。
        
- **流程**：显存送 ASCII 码 $\rightarrow$ 字符发生器查表 $\rightarrow$ 并串转换 $\rightarrow$ 视频信号控制电子枪。
    

### 🧠 总结

这三节课建立了一个完整的显示链条：

1. **概念**：我们要画的是光栅扫描的图像。
    
2. **模式**：我们要么按字符画（省显存），要么按像素画（精细）。
    
3. **原理**：电子束在锯齿波驱动下扫描全屏，视频信号控制亮灭，字符发生器负责把 ASCII 码翻译成点阵形状。


# 5. 屏幕显示与显示器缓存的对应关系


这一节 **6.2.5 屏幕显示与显示器缓存 (VRAM) 的对应关系**（课件 P22-P26）是本章最核心的**计算题**和**分析题**考点。

它揭示了计算机内部的 **0/1 数据** 是如何变成屏幕上的 **图像** 的。这中间有一个关键的中转站：**显存 (VRAM)**。

我们从 **容量计算**、**地址映射**、**信号转换** 三个维度来解析。

---

### 一、显存的内容与容量计算 (Content & Capacity)

显存里存的东西取决于显示模式（字符模式 vs 图形模式）。

#### **1. A/N 方式 (字符/数字模式)**

- **存什么？** 存字符的 **ASCII 码**（通常 1 个字节）和 **属性**（颜色/闪烁等，通常 1 个字节）。
    
- 容量计算公式：
    
    $$\text{显存容量} = \text{行数} \times \text{列数} \times \text{每字符字节数}$$
    
- **课件例子 (P22)**：
    
    - 规格：25 行 $\times$ 80 列。
        
    - 基本容量（只存 ASCII）：$25 \times 80 \times 1\text{B} = 2000\text{B} \approx 2\text{KB}$。
        
    - _注：这就是为什么早期的 DOS 系统显存只要几 KB 就够了。_
        

#### **2. APA 方式 (图形模式)**

- **存什么？** 存每一个像素点的 **颜色/亮度信息**（位图）。
    
- 容量计算公式：
    
    $$\text{显存容量 (Byte)} = \frac{\text{分辨率 (点数)} \times \text{颜色深度 (位数)}}{8}$$
    
- **课件例子 (P23)**：
    
    - 规格：$640 \times 200$ 分辨率，单色（1 位/点）。
        
    - 计算：$(640 \times 200 \times 1) / 8 = 16,000\text{B} \approx 16\text{KB}$。
        
- **权衡关系**：显存固定时，分辨率越高，能显示的颜色就越少；颜色越多，分辨率就得降低。
    

---

### 二、显存的地址组织 (Address Mapping)

屏幕是一个二维平面（行, 列），而内存是一个一维线性空间（地址）。如何映射？

- **线性映射**：屏幕从 **左上角** 开始，**从左向右**，**自上而下** 扫描。显存地址也随之 **从低到高** 线性排列。
    
- **对应关系**：
    
    - **屏幕行号** $\rightarrow$ 决定显存地址的 **高位**（大跨度）。
        
    - **屏幕列号** $\rightarrow$ 决定显存地址的 **低位**（小跨度）。
        
    - _公式_：$\text{显存地址} = \text{基址} + (\text{行号} \times \text{每行字节数}) + \text{列偏移}$。
        

---

### 三、信息转换流程 (Information Conversion) —— **⭐ 核心硬件原理**

这就是显卡工作的**流水线**。怎么把静止的显存数据变成动态的视频流？

#### **1. A/N 方式的处理流程 (P25 必考图解)**

![[Pasted image 20251229202928.png]]

在字符模式下，显存里只有 "A" 的 ASCII 码（比如 41H），屏幕上怎么画出 "A" 的形状？靠 **字符发生器 (ROM)**。

1. **读取**：从 **VRAM** 读出字符的 **ASCII 码**。
    
2. **翻译**：将 **ASCII 码** + **当前扫描行号** 送入 **字符发生器 (ROM)**。
    
    - ROM 查表输出该字符在当前行的 **点阵代码**（并行数据，如 `0010000`）。
        
3. **串行化**：并行点阵代码送入 **移位寄存器**，在时钟推动下变成 **串行视频信号**。
    
4. **显示**：视频信号控制电子枪开关，在屏幕上画出点。
    

#### **2. APA 方式的处理流程 (P26)**

![[Pasted image 20251229202939.png]]

图形模式简单粗暴，显存里存的就是“图”。

1. **读取**：从 **VRAM** 直接读取 **像素数据**（如 `00001111`）。
    
2. **串行化**：直接送入 **移位寄存器**。
    
3. **显示**：变成串行视频信号控制显示。
    

---

### 🧠 总结：显存里的秘密

| **比较维度** | **A/N 字符模式**       | **APA 图形模式**    |
| -------- | ------------------ | --------------- |
| **显存内容** | **ASCII 码** (抽象代码) | **像素位图** (真实图像) |
| **容量需求** | **极小** (KB 级)      | **大** (MB/GB 级) |
| **核心硬件** | 需要 **字符发生器 (ROM)** | 不需要 ROM，直接输出    |
| **灵活性**  | 只能显示固定字形           | 任意画图            |



# 6. 显示过程总结


### 1. 核心流程：从 CPU 到 屏幕 (The Data Flow)

无论是字符模式还是图形模式，显示过程都可以概括为以下 **5 个步骤**：

#### **第一步：CPU 写显存 (Update VRAM)**

- **动作**：CPU 根据应用程序的需求，将要显示的内容（ASCII 码或像素颜色）写入到 **显存 (VRAM)** 中。
    
- **状态**：此时数据是静止的，存储在 VRAM 里。
    

#### **第二步：显示控制器读显存 (Fetch Data)**

- **动作**：显示控制器内部的 **时序电路（计数器）** 产生扫描地址，不停地从 VRAM 中读取当前扫描位置对应的数据。
    
- **关键**：这个读取过程必须与电子束在屏幕上的扫描位置（行、列）严格同步 。
    

#### **第三步：数据转换 (Translation)**

这是字符模式和图形模式的分叉点：

- **A/N 字符模式**：
    
    - 读到的是 **ASCII 码**。
        
    - 需要拿着 ASCII 码和当前扫描行号，去查 **字符发生器 (ROM)**，翻译成 **点阵代码** 。
        
- **APA 图形模式**：
    
    - 读到的直接就是 **像素点代码**，不需要查表 。
        

#### **第四步：并-串转换 (Serialization)**

- **动作**：从 VRAM 或 ROM 出来的都是 **并行数据**（比如一次出来 8 位，代表 8 个横向的点）。
    
- **处理**：送入 **移位寄存器**，在点时钟的推动下，一位一位地挤出来，变成 **串行视频信号** 。
    

#### **第五步：控制显示 (Display Control)**

- **动作**：串行信号控制电子枪的 **亮/灭**（Z 轴信号），配合水平/垂直 **同步信号**（X/Y 轴偏转），最终在屏幕上画出图像 。
    

---

### 2. 关键硬件协同 (Hardware Coordination)

这个过程体现了三个关键部件的完美配合：

1. **VRAM (仓库)**：负责存“草图”（ASCII 或位图）。
    
2. **ROM (画师)**：负责把“草图”细化成“笔画”（仅字符模式）。
    
3. **移位寄存器 (传送带)**：负责把“笔画”变成连续的“动作流”。