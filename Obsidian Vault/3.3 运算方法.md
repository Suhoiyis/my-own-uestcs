# 定点加减运算


首先我们要掌握的是最基础、也是最高频的操作：**定点加减运算**。

在计算机（模型机）中，定点数的加减法几乎完全是基于 **补码 (Two's Complement)** 来实现的。

根据课件 **P4-P7** 的内容，我为你总结了三个核心要点：

### 1. 核心公式：把减法变成加法

计算机非常“懒”，它不想专门设计一个“减法电路”。通过补码，我们可以把所有的减法都变成加法来算。

- 加法公式：
    
    $$[X+Y]_{\text{补}} = [X]_{\text{补}} + [Y]_{\text{补}}$$
    
    - **含义**：直接把两数的补码相加，**符号位当作数值一样参与运算**。
        
- 减法公式：
    
    $$[X-Y]_{\text{补}} = [X]_{\text{补}} + [-Y]_{\text{补}}$$
    
    - **含义**：$X$ 减 $Y$，等于 $X$ 加上 “$Y$ 的负数” 2。
        

---

### 2. 关键技术：“变补” (Negation)

怎么求 $[-Y]_{\text{补}}$ 呢？这就是**“变补”**操作（也叫求补）。

- **规则**：将 $[Y]_{\text{补}}$ **连同符号位**一起，**各位变反，末位加 1**。
    
- **硬件实现**：
    
    - **加法**：$A + B$
        
    - **减法**：$A + \bar{B} + 1$ （这里 $\bar{B}$ 就是 B 的反码，那个 $+1$ 由加法器的进位输入 $C_0$ 提供）。
        

---

### 3. 硬件实现逻辑 (必考图解)

请重点看 **PPT 第 7 页** 的这张图，它展示了加减法是如何共用一套硬件的。
![[Pasted image 20251229160736.png]]
**这张图的运行逻辑如下：**

1. **输入端**：
    
    - **$A$ 寄存器**：存放被加数（或被减数）。
        
    - **$B$ 寄存器**：存放加数（或减数）。
        
2. **选择逻辑 (核心)**：
    
    - 做 **加法** 时：控制命令选通 `+B`，并且最低位进位设为 0。算的是 $A + B$。
        
    - 做 **减法** 时：控制命令选通 `+/B` (即 $\bar{B}$)，并且最低位进位设为 `+1`。算的是 $A + \bar{B} + 1$。
        
3. **输出端**：
    
    - 运算结果 $\Sigma$ 会被送回 **$A$ 寄存器** 保存 5。
        

---

### 🧠 总结与考点

这一小节在考试中通常考察以下两点：

1. **计算题**：给你两个十进制数（比如 $x=18, y=-125$），让你用补码计算 $[x-y]_{补}$。
    
    - _步骤_：先转二进制 -> 求补码 -> 把减数“变补” -> 相加 -> 结果转回真值。
        
2. **溢出判断**：虽然这几页 PPT 没详细展开，但在 **P5** 的例子中使用了 **双符号位 (00, 11)**。
    
    - **双符号位判溢出**：结果的两个符号位如果不一致（01 或 10），就说明溢出了。


# 定点乘法运算


### 1. 定点乘法运算 (Fixed-point Multiplication)

乘法的本质是：**判断乘数的每一位，决定是被乘数“加”进去还是“不加”，然后错位（移位）对齐**。

根据操作数的形式，分为两种主要方法：

#### **① 原码一位乘法 (Original Code Multiplication)**

- **原理**：**“先算数值，再定符号”**。
    
    - 取两数的**绝对值**相乘，符号位单独处理（异或运算）。
        
- **流程**：
    
    - 看乘数（寄存器 C）的最后一位 $C_n$。
        
    - 若 $C_n=1$：加被乘数 (A+B)，然后右移。
        
    - 若 $C_n=0$：加 0，直接右移。
        
- **特点**：简单直观，但需要把符号位和数值分开处理。
    

#### **② 补码一位乘法 (Booth算法 / Complement Multiplication)**

- **原理**：**“符号位参与运算”**。
    
    - 操作数直接用补码进行计算，符号位自然形成 5。
        
- **核心方法 (Booth算法)**：
    
    - 不再只看 1 位，而是看**末尾 2 位**（$Y_n$ 和附加位 $Y_{n+1}$）的变化 6。
        
    - **判断规则** 7：
        
        - `00` 或 `11`：**不加**，直接右移。
            
        - `01`：**加 $X_{补}$**，右移。
            
        - `10`：**加 $-X_{补}$** (即减去 X)，右移。
            
- **特点**：处理负数非常方便，是现代计算机常用的乘法算法。
    

---

### 2. 定点除法运算 (Fixed-point Division)

除法的本质是：**不断的“试商”和“减法”**。看够不够减，够减商 1，不够减商 0。

为了提高速度，计算机通常采用**不恢复余数法**（也叫**加减交替法**），避免了“不够减还要加回去（恢复余数）”的麻烦。

#### **① 原码不恢复余数除法**

- **原理**：**“够减商1，不够商0”**，符号位单独处理 8。
    
- **核心逻辑** 9：
    
    - 如果余数 $r_i$ 为正（够减）：商上 1，下一步做 **减法** ($2r_i - Y$)。
        
    - 如果余数 $r_i$ 为负（不够减）：商上 0，下一步做 **加法** ($2r_i + Y$)。
        
- **特点**：通过加减交替逼近结果，步数固定。注意最后一步如果余数为负，需要恢复余数 10。
    

#### **② 补码不恢复余数除法**

- **原理**：**“符号位参与运算”**，不需要单独算符号 11。
    
- **核心逻辑**：
    
    - 看**余数**和**除数**的符号是同号还是异号，来决定是“加”还是“减”，以及商是“1”还是“0” 12。
        
    - 规则相对复杂，涉及到**假商符**的判断。
        

---

### 🚀 总结对比

| **运算类型** | **方法核心** | **符号处理**  | **关键动作**                                          |
| -------- | -------- | --------- | ------------------------------------------------- |
| **原码乘法** | 绝对值运算    | 单独处理 (异或) | **加 B** 或 **不加**，然后右移                             |
| **补码乘法** | Booth算法  | **参与运算**  | **加 B**、**减 B** 或 **不加**，然后右移                     |
| **原码除法** | 加减交替法    | 单独处理      | 余数为正 $\rightarrow$ **减**；余数为负 $\rightarrow$ **加** |
| **补码除法** | 加减交替法    | **参与运算**  | 根据同号/异号判断加减                                       |

复习建议：

考试中，**“原码乘法”和“补码乘法（Booth）”**的计算过程（列表格求解）是重中之重。特别是 Booth 算法中 01 加、10 减的规则，一定要熟练掌握。