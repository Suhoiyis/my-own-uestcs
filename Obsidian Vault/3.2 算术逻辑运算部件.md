
# 加法单元

最基本的构建模块：**一位全加器 (Full Adder, FA)**。

#### 1. 核心概念：本位操作与进位

我们要计算一位二进制加法（比如 $A_i + B_i$），需要考虑三个输入和两个输出：

- **输入**：
    
    - **$A_i$**：加数（本位）。
        
    - **$B_i$**：被加数（本位）。
        
    - **$C_{i-1}$**：**低位进位**（来自低一位计算产生的进位）。这是“全”加器的关键，半加器就没有这个。
        
- **输出**：
    
    - **$\Sigma_i$**：**本位和**（当前位的计算结果）。
        
    - **$C_i$**：**本位进位**（要送给高一位的进位信号）。
        

#### 2. 逻辑公式 (必背)

课件中给出了两个至关重要的逻辑表达式 1，这是设计加法器电路的基础：

- 本位和 $\Sigma_i$：
    
    $$\Sigma_i = A_i \oplus B_i \oplus C_{i-1}$$
    
    - _理解_：三个输入中，如果有**奇数个 1**，结果就是 1。异或运算（$\oplus$）就是做这个的。
        
- 本位进位 $C_i$：
    
    $$C_i = A_i B_i + (A_i \oplus B_i) C_{i-1}$$
    
    - _理解_：什么时候会产生进位？
        
        1. **$A_i B_i$**：自己两个数都是 1（比如 1+1），肯定进位。
            
        2. **$(A_i \oplus B_i) C_{i-1}$**：自己两个数有一个是 1（比如 1+0），且低位进位来了个 1（变成 1+0+1），也要进位。
            

#### 3. 逻辑电路图

课件 P7 给出了对应的逻辑门电路图。

- **和 ($\Sigma$)**：用了两个异或门级联。
    
- **进位 ($C$)**：用了与门、或门和异或门组合。
    

---

### 🎯 学习重点与考点

这一小节虽然短，但是是后面理解“串行加法器”和“并行加法器”的基础。

1. **全加器与半加器的区别**：
    
    - **考点**：全加器有 $C_{i-1}$ 输入，半加器没有。多位加法必须用全加器。
        
2. **进位产生的条件**：
    
    - **考点**：给你 $A_i, B_i, C_{i-1}$ 的值，能迅速算出 $C_i$ 和 $\Sigma_i$。
        
    - _例子_：$1 + 0 + 1$ (低位进位) $\rightarrow$ Sum=0, Carry=1。
        
3. **公式的记忆**：
    
    - 特别是进位公式 $C_i = G_i + P_i C_{i-1}$ 的形式（这里 $G_i = A_i B_i$ 叫进位产生，$P_i = A_i \oplus B_i$ 叫进位传递），这是后面讲**并行进位链**的核心。
        

---

### 💡 思考题

为了检验你是否掌握了“进位”的逻辑，试着想一下：

**如果是 4 位二进制数相加，第 0 位（最低位）的全加器，它的 $C_{-1}$（来自更低位的进位）通常应该接什么电平？是 0 还是 1？**



# 串行加法器

![[Pasted image 20251229155454.png]]

最节省硬件资源，但速度最慢的加法器设计——**串行加法器 (Serial Adder)**。

如果说并行加法器是“人多力量大”（多个人同时算每一位），那么串行加法器就是“一个人干所有的活”（一个人从低位算到高位）。

### 1. 核心思想

**“时间换空间”**。

- 它利用**一个**全加器，在**n 个时钟周期**内，依次计算 n 位数据的加法 1。
    
- 就像我们在纸上做加法一样，先算个位，记下进位；再算十位，加上刚才的进位……以此类推。
    

### 2. 硬件组成 (必考点)

你需要记住它由哪四个关键部件组成：

- **1 个全加器 (FA)**：这是核心劳模，每次只负责算 1 位。
    
- **1 个进位触发器 (D Flip-Flop)**：**这是串行加法器的灵魂**。
    
    - _作用_：它负责“记忆”。算第 $i$ 位时产生的进位 $C_i$，要先存在这里，等到下一个时钟周期算第 $i+1$ 位时，再把它吐出来作为低位进位 $C_{i-1}$ 使用。
        
- **2 个移位寄存器 ($A_i, B_i$)**：
    
    - _作用_：它们像传送带一样，每个节拍向右移动一位，把当前要计算的那一位数字送到全加器的门口。
        
    - _注_：计算出来的和 $\Sigma_i$ 通常会由高位回填到寄存器 A 中（如图中 ④ 所示） 3。
        

### 3. 工作流程

想象一下 $A=1101, B=1011$ 相加的过程：

1. **节拍 1**：寄存器送出最低位 $1$ 和 $1$。全加器计算 $1+1=0$ (进位1)。
    
    - 和 $0$ 存回寄存器。
        
    - 进位 $1$ **存入 D 触发器**。
        
2. **节拍 2**：寄存器右移，送出下一位 $0$ 和 $1$。全加器计算 $0+1+\mathbf{1(来自D触发器)} = 0$ (进位1)。
    
    - 进位 $1$ 更新 D 触发器。
        
3. ...以此类推，直到算完所有位。
    

### 4. 特点总结

- **优点**：**结构最简单**。不管算多少位的加法，只需要一个全加器，硬件成本极低 4。
    
- **缺点**：**速度极慢**。计算 n 位数需要 n 个时钟周期。如果字长是 64 位，它就得算 64 次，这在现代高速计算中是无法忍受的 5。
    

---

### 💡 学习提示

考试中经常会把串行加法器和后面要讲的并行加法器放在一起对比。

你只需要抓住关键区别：

- **串行**：有 **D 触发器**（存进位），只有 **1 个全加器**。
    
- **并行**：没有触发器存进位（进位是即时传递的），有 **n 个全加器**。


# 并行加法器

![[Pasted image 20251229155545.png]]


并行加法器的核心矛盾：**进位信号的传递速度**。

### 1. 核心定义

- **并行加法器**：由 **n 个全加器** 组成，空间上并行排列，一次性对 n 位数据进行相加。
    
- **瓶颈**：虽然加法动作是同时的，但**高位的进位必须等待低位的进位产生**才能确定。这就像多米诺骨牌，推倒（进位）需要时间传递。
    

---

### 2. 两种关键的进位方式 (必考对比)

根据“进位信号是怎么来的”，并行加法器分为两类：

#### ① 串行进位 (Ripple Carry) —— “接力赛”

- **原理**：把 n 个全加器串联起来。第 $i$ 位的进位输出 $C_i$ 直接连到第 $i+1$ 位的进位输入 $C_i$。
    
- **逻辑**：$C_i$ 依赖于 $C_{i-1}$。
    
    - 第 1 位算完，传给第 2 位；第 2 位算完，传给第 3 位……
        
- **特点**：
    
    - **优点**：电路简单，只要把全加器连起来就行。
        
    - **缺点**：**速度慢**。高位必须死等低位，位数越多越慢（延迟是 $O(n)$）。
        

#### ② 并行进位 (Carry Lookahead) —— “预知未来”

也叫**先行进位**。这是为了打破“接力赛”的等待而发明的。

- **原理**：不等待低位的计算结果，而是直接根据输入数据（$A$ 和 $B$）和最低位进位（$C_0$），利用复杂的逻辑电路**瞬间同时算出所有位的进位信号**。
    
- 核心公式 (必背)：
    
    课件 P11 推导了两个关键辅助变量：
    ![[Pasted image 20251229155942.png]]
    - **进位产生函数 $G_i = A_i B_i$**：只要 $A, B$ 都是 1，本位一定产生进位（不管低位）。
        
    - **进位传递函数 $P_i = A_i \oplus B_i$**：如果 $A, B$ 有一个是 1，那么低位有进位我就传下去。
        
    - **进位公式**：$C_i = G_i + P_i C_{i-1}$。
        
- **展开结果**（P12）：
    ![[Pasted image 20251229160013.png]]
    - $C_1 = G_1 + P_1 C_0$
        
    - $C_2 = G_2 + P_2 G_1 + P_2 P_1 C_0$
        
    - ...
        
    - **结论**：任何一位的进位 $C_n$ 都可以只用 $G, P$ 和最初的 $C_0$ 表示，**与前一位的进位无关**！
        
- **特点**：
    
    - **优点**：**速度极快**，所有进位同时产生。
        
    - **缺点**：电路极其复杂，位数多了之后硬件开销爆炸。
        

---

### 3. 分组进位 (Grouped Carry) —— 现实的妥协

因为完全的并行进位电路太复杂（想想 $C_{16}$ 的公式会有多长），实际设计中通常采用“**分组**”策略（课件 P14-P17）。
![[Pasted image 20251229160131.png]]
比如 16 位加法器，分成 4 组，每组 4 位：

1. **组内并行**：小组内部（4位）使用**并行进位**，速度快。
    
2. **组间串行/并行**：
    
    - **组间串行**（单级先行进位）：组内快，但组和组之间还是像接力赛一样传进位。
        
    - **组间并行**（多级先行进位）：组和组之间也用并行进位逻辑，速度最快，但设计最难。
        

---

### 💡 学习重点总结

1. **记公式**：一定要记住 $G_i = A_i B_i$ 和 $P_i = A_i \oplus B_i$ 的含义和表达式，这是并行进位的灵魂。
    
2. **理解差异**：
    
    - 串行进位 = 依赖上一位 = 慢、简单。
        
    - 并行进位 = 依赖输入数据和 $C_0$ = 快、复杂。
        
3. **分组策略**：理解为什么要分组（为了平衡速度和硬件成本）。


# 四、ALU单元与多位ALU部件

![[Pasted image 20251229160222.png]]


如果说前面的“加法器”是单一功能的计算器，那么 **ALU（算术逻辑单元）** 就是一个**多功能瑞士军刀**。它不仅能算加减，还能做逻辑运算（与、或、非、异或），而且把这些功能集成在了一个芯片里。

这一节非常简短，主要介绍了 ALU 是如何从“加法器”进化而来的。

### 1. 核心定义

**ALU 逻辑**并不是重新发明轮子，而是将以下三个模块**集成**在一块芯片上：

1. **若干位全加器**：负责核心算术计算。
    
2. **并行进位链**：负责快速生成进位（我们在上一节学的）。
    
3. **输入选择门**：这是 ALU 区别于普通加法器的关键，它决定了数据进入加法器之前怎么“变身”（比如取反、置 0），从而实现减法或逻辑运算。
    

### 2. 一位 ALU 逻辑的组成 (1-bit ALU)

这是构成多位 ALU 的基本细胞。它包含三个关键部分 2：

- **1 位加法器**：最苦力的部分，负责求和 ($\Sigma$) 和进位 ($C$)。
    
- **1 位输入选择器**：通常由一对“与或非门”组成。
    
    - _作用_：它像个变魔术的，在数据进入加法器之前，可以对输入 $A$ 和 $B$ 进行处理（比如把 $B$ 变成 $\bar{B}$ 就可以做减法）。
        
- **1 个公共控制门**：
    
    - _作用_：**模式选择开关**。它决定了当前是做**算术运算**（需要处理进位）还是**逻辑运算**（不需要进位，各位独立）。
        

### 3. 逻辑关系式

课件中给出了 1 位 ALU 的核心逻辑公式：

- **求和逻辑**：$\Sigma_{i}=(A_{i}\oplus B_{i})\oplus C_{i-1}$
    
    - 这和全加器是一样的。
        
- **进位逻辑**：$C_{i}=A_{i}B_{i}+(A_{i}\oplus B_{i}) C_{i-1}$
    
    - 也就是我们之前学的 $G_i + P_i C_{i-1}$。
        

### 4. 多位 ALU 部件

实际的 CPU 不会只用 1 位 ALU，而是把它们拼起来。

- **4 位 ALU 芯片**：课件提到了参照相关章节（通常指经典的 **SN74181** 芯片）。
    
- **构建方式**：通过把多个 1 位 ALU 单元连起来，配合**并行进位链**，就构成了我们在 CPU 数据通路中看到的那个核心部件 —— **ALU**。
    

---

### 🎓 第三章复习总结：算术逻辑运算部件

恭喜你，学完了 **3.2 算术逻辑运算部件**！回顾这一整节，逻辑是非常连贯的：

1. **一位全加器**：最基础的砖块，解决了 1 位数的相加和进位问题。
    
2. **串行加法器**：用 1 个全加器 + 触发器，省钱但慢，像一个人干活。
    
3. **并行加法器**：用 n 个全加器，但受限于进位传递（多米诺骨牌）。
    
    - **解决方案**：**并行进位（先行进位）**，用 $G$ 和 $P$ 函数瞬间算出所有进位。
        
4. **ALU**：在并行加法器前面加了“输入选择”，实现了加减乘除和逻辑运算的统一。