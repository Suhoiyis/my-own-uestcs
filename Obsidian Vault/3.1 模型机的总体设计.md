
## CPU的组成

根据课件内容，模型机 CPU 的硬件架构主要由以下四大模块组成：

### 1. 运算器 (Arithmetic Unit) —— 数据的加工厂

模型机的运算器采用了独特的**三级结构**，数据像流水线一样流过它们 1：

- **第一级：输入选择器/锁存器 (Latch)** 2
    
    - 作用：作为 ALU 的“看门人”，负责从众多的寄存器（R0-R3, PC, SP 等）中选择两个操作数（A口和 B口），暂存下来送给 ALU。
        
- **第二级：ALU (算术逻辑单元)** 3
    
    - 作用：核心计算部件。根据控制信号（微命令）执行加、减、与、或等算术或逻辑运算。
        
- **第三级：移位器 (Shifter)** 4
    
    - 作用：对 ALU 算出来的结果进行加工，比如左移、右移或直接传送。
        
    - _特点_：数据必须经过这里才能送往总线，它实际上也起到了输出缓冲的作用。
        

### 2. 寄存器组 (Registers) —— 数据的临时存放点

这是本节的**绝对重点**。你需要分清哪些是程序员能用的，哪些是 CPU 自己私藏的。

- **通用寄存器 (General Purpose Registers)** 5
    
    - **$R_0 \sim R_3$**：程序员可见，用于存放操作数或中间结果。
        
- **专用寄存器 (Special Purpose Registers)**：
    
    - **PC (程序计数器)**：存放**下一条**指令的地址 6。
        
    - **SP (堆栈指针)**：管理堆栈的栈顶地址 7。
        
    - **PSW (程序状态字)**：存放运算结果的状态（如溢出 V、进位 C、零 Z、负 N） 8。
        
    - **IR (指令寄存器)**：存放**当前正在执行**的指令。它的输出直接决定了控制逻辑产生什么微命令 9。
        
- **接口寄存器 (Interface Registers)** —— CPU 与内存沟通的桥梁 ：
    
    - **MAR (地址寄存器)**：单向，存放要访问的内存单元地址。带有三态门控制（EMAR），决定何时把地址送到地址总线 11。
        
    - **MDR (数据缓冲寄存器)**：双向，存放从内存读来或要写入内存的数据 。
        
- **暂存器 (Temporary Registers)** —— **用户不可见** 
    
    - **C 和 D**：这是 CPU 内部的“草稿纸”。比如从内存取回一个数，不能一直放在数据总线上，得先找个地方（比如 C 或 D）存一下，才能送进 ALU 运算。


### 3. 总线 (Bus) —— 数据的血管

- **CPU 内总线**：模型机采用的是**单组、单向**总线结构 14。这意味着同一时刻只能有一个部件向总线发送数据，数据也是单向流动的（通常是流向寄存器）。
    
- **系统总线**：连接 CPU、内存和 I/O 设备，分为地址总线 (AB)、数据总线 (DB) 和控制总线 (CB) 15。
    

### 4. 时序系统 (Timing System) —— CPU 的心跳

- **作用**：计算机的动作是分步执行的，时序系统负责产生节拍和脉冲，指挥所有部件按部就班地工作 16。
    
- **层级**：指令周期 > 机器周期 (CPU 周期) > 时钟周期 (节拍) > 定时脉冲 17。
    

---

### 💡 学习重点总结

对于这一部分，建议你重点掌握以下几点（通常是考试的选择题或填空题考点）：

1. **寄存器的可见性**：
    
    - **考点**：哪些寄存器是汇编程序员可以编程访问的？（答案：R0-R3, PC, SP, PSW）。哪些是透明的/不可见的？（答案：MAR, MDR, IR, 暂存器 C/D）。
        
2. **MAR 和 MDR 的作用**：
    
    - **考点**：如果要从内存读一个数据，地址先去哪？（MAR）。数据读回来先存在哪？（MDR）。
        
3. **ALU 的三级结构**：
    
    - **考点**：数据流向是 `输入选择 -> ALU -> 移位器 -> 总线`。理解为什么要经过移位器（即使不移位也要“直传”），因为它充当了 ALU 到总线的缓冲驱动。






## CPU的内部数据通路结构

![[Pasted image 20251229150404.png]]


### 1. 核心架构：单总线结构的“瓶颈”与“规矩”

模型机采用了**单组、单向内总线**结构 1。这意味着数据流动有非常严格的规矩，这是理解所有数据通路的基础：

- **“独木桥”效应**：任何时刻，总线上只能有一个部件在发送数据（否则会冲突）。
    
- **ALU 是核心枢纽**：在模型机中，几乎所有的数据传送（即使不进行加减运算）都要“路过”ALU。
    
    - **标准路径**：`源寄存器` $\rightarrow$ `输入选择器(A/B)` $\rightarrow$ `ALU` $\rightarrow$ `移位器` $\rightarrow$ `内总线` $\rightarrow$ `目的寄存器` 2222222。
        
        +2
        
    - **为什么这么麻烦？** 因为寄存器不能直接把数据送上总线，必须通过 ALU 和移位器（作为驱动/缓冲）才能上去。
        

### 2. 关键操作流程 (Micro-operations) —— **必考重难点**

你需要掌握不同阶段、不同寻址方式下的数据流向。建议对照 **P32 的框图** 来记忆。

#### A. 取指阶段 (公共操作)

不管什么指令，开头这三步是一样的：

1. **送指令地址**：`PC` $\rightarrow$ `A` $\rightarrow$ `ALU` $\rightarrow$ `移位器` $\rightarrow$ `总线` $\rightarrow$ `MAR` 。 ![[Pasted image 20251229150619.png]]
    
    - _含义_：告诉内存我要取哪条指令。
        
2. **读指令内容**：`Memory` $\rightarrow$ `数据总线` $\rightarrow$ `MDR` $\rightarrow$ `B` $\rightarrow$ `ALU` $\rightarrow$ `移位器` $\rightarrow$ `总线` $\rightarrow$ `IR` 。
![[Pasted image 20251229150658.png]]
    
    - _含义_：把指令读进来存到 IR 里。
        
3. **PC+1**：`PC` $\rightarrow$ `A` $\rightarrow$ `ALU(+1)` $\rightarrow$ `移位器` $\rightarrow$ `总线` $\rightarrow$ `PC` 5。
    
    - _含义_：准备好下一条指令的地址。
        

#### B. 寻址阶段 (计算操作数地址)

##### 1. 寄存器间接寻址 `(R)` —— “最直接的间接”
![[Pasted image 20251229151254.png]]

这是最基础的模式，不需要计算，只需要“搬运”。

- **目标**：把 $R_i$ 里的内容（它是地址）送到 MAR，准备去内存取数。
    
- 数据通路（课件 P37）：
    
    $R_i \rightarrow A/B \rightarrow ALU(传送) \rightarrow 移位器 \rightarrow CPU内总线 \rightarrow MAR$ 1
    
- **关键点**：ALU 在这里不做加减，只做“直传”。
    

---

##### 2. 自减型寄存器间址 `-(R)` —— “先减后送”

这是**并行操作**的典型例子。
![[Pasted image 20251229151331.png]]

- **目标**：把寄存器 $R_i$ 的值减 1，**新值**既要存回 $R_i$（更新指针），又要送到 MAR（作为地址）。
    
- 数据通路（课件 P38）：
    
    $R_i \rightarrow A/B \rightarrow ALU(减1) \rightarrow 移位器 \rightarrow CPU内总线 \rightarrow R_i, MAR$ 2
    
- **关键点**：
    
    1. **ALU 做减法**：数据经过 ALU 时被减了 1。
        
    2. **双重写入**：总线上的数据同时流向了 **$R_i$**（更新自己）和 **MAR**（去取数）。这是一步完成的！
        

---

##### 3. 自增型寄存器间址 `(R)+` —— “先用后加”
![[Pasted image 20251229151407.png]]

- **目标**：先用 $R_i$ 里的**旧值**做地址，事后 $R_i$ 再加 1。
    
- 取地址阶段的数据通路（课件 P39）：
    
    $R_i \rightarrow A/B \rightarrow ALU(传送) \rightarrow 移位器 \rightarrow CPU内总线 \rightarrow MAR$
    
- **关键点**：你可能会问“加 1 去哪了？”。在“取操作数地址”这一步，它**和普通的寄存器间址完全一样**。$R_i$ 的自增操作通常安排在后续的时序中（比如下一个节拍），课件这里重点展示的是“如何获得操作数地址”。
    

---

##### 4. 自增型双重间址 `@(R)+` —— “套娃寻址” (最复杂之一)


这个寻址方式非常繁琐，因为它要访问两次内存，CPU 内部要走**三步**（课件 P40-P42）：

- **第一步：送间接地址**（拿出藏宝图的坐标）
    ![[Pasted image 20251229151454.png]]
    - 通路：$R_i \rightarrow ... \rightarrow MAR$
        
    - _含义_：告诉内存，$R_i$ 指向哪里。
        
- **第二步：取操作数地址**（拿到藏宝图）
	![[Pasted image 20251229151521.png]]
    
- 通路：$主存(M) \rightarrow 数据总线 \rightarrow MDR \rightarrow B \rightarrow ALU \rightarrow 移位器 \rightarrow CPU内总线 \rightarrow C$
    
- _含义_：从内存读出来的还不是数据，是**最终地址**。因为 MDR 马上要用来存别的东西，或者 ALU 还没准备好，所以先把这个地址**暂存在 C** 里。
        
- **第三步：送操作数地址**（去挖宝）
    ![[Pasted image 20251229151540.png]]
    - 通路：$C \rightarrow A/B \rightarrow ALU \rightarrow ... \rightarrow MAR$ 6
        
    - _含义_：把暂存在 C 里的最终地址拿出来，送到 MAR，准备去取真正的操作数。
        

---

##### 5. 变址寻址 `X(R)` —— “计算有效地址”

这也是一个**三步走**的过程，涉及到了 **PC** 和 **ALU 加法**（课件 P43-P45）：

- **第一步：送形式地址的地址**（去找偏移量 D 在哪）
    ![[Pasted image 20251229152146.png]]
    - 通路：$PC \rightarrow ... \rightarrow MAR$
        
    - _含义_：偏移量 D 是指令的一部分，指令在内存里，所以要用 PC 的地址去读它。
        
- **第二步：取形式地址**（读出 D）
    ![[Pasted image 20251229152154.png]]
    - 通路：$主存(M) \rightarrow ... \rightarrow MDR \rightarrow ... \rightarrow C$ 8
        
    - _含义_：把读出来的偏移量 D **暂存在 C**。
        
- **第三步：计算有效地址**（核心计算）
    ![[Pasted image 20251229152202.png]]
    - 通路：$C (即D) + R_i (变址值) \rightarrow ALU(加法) \rightarrow ... \rightarrow MAR$ 9
        
    - _含义_：**C 走 A 口，Ri 走 B 口**（或反之），ALU 算出最终地址，直接送到 MAR。
        

---

### 🌟 总结与对比表

|**寻址方式**|**核心动作**|**涉及的特殊寄存器**|**步骤数**|**关键微操作**|
|---|---|---|---|---|
|**(R)**|直传|无|1|$R_i \to MAR$|
|**-(R)**|**先减**后传|无|1|$R_i-1 \to R_i, MAR$|
|**(R)+**|先传(后加)|无|1|$R_i \to MAR$ (加操作滞后)|
|**@(R)+**|取地址的地址|**C (暂存)**|**3**|$M \to C$; $C \to MAR$|
|**X(R)**|**计算**地址|**C (暂存)**|**3**|$M(PC) \to C$; $C+R_i \to MAR$|

重点提示：

考试如果让你画 变址寻址 或 双重间址 的数据通路，千万别忘了中间那个 暂存器 C！因为从内存读回来的数据（无论是偏移量还是间接地址）不能直接悬空，必须先找个地方（C）存一下，才能在下一步送入 ALU 进行处理或转发。
        

#### C. 数据传送阶段

下是课件中列出的完整 **数据传送阶段** 的 6 种变体：

---

##### 1. 寄存器 $\rightarrow$ 寄存器 (CPU 内部)
![[Pasted image 20251229152637.png]]

- **场景**：比如 `MOV R0, R1`。这是最简单的，数据不出 CPU 大门。
    
- 路径 (课件 P46)：
    
    $R_i \rightarrow A/B \rightarrow ALU(直传) \rightarrow 移位器 \rightarrow 内总线 \rightarrow R_j$ 1
    
- **关键点**：纯内部流动，速度最快。
    

---

##### 2. 寄存器 $\rightarrow$ 主存 (写数据)
![[Pasted image 20251229152658.png]]
- **场景**：比如 `MOV (R1), R0` (把 R0 的值存入 R1 指向的内存)。
    
- **路径** (课件 P47)：
    
    1. $R_i \rightarrow A/B \rightarrow ALU \rightarrow 移位器 \rightarrow 内总线 \rightarrow MDR$
        
    2. $MDR \rightarrow 数据总线 \rightarrow 主存(M)$
        
- **关键点**：数据不能直接去内存，必须先在 **MDR** 停留。**MDR 是出入内存的必经之门**。
    

---

##### 3. 主存 $\rightarrow$ 寄存器 (读数据)
![[Pasted image 20251229152819.png]]
- **场景**：比如 `MOV R0, (R1)` (把 R1 指向的内存值读到 R0)。
    
- **路径** (课件 P48)：
    
    1. $主存(M) \rightarrow 数据总线 \rightarrow MDR$ 4
        
    2. $MDR \rightarrow B \rightarrow ALU \rightarrow 移位器 \rightarrow 内总线 \rightarrow R_i$ 5
        
- **关键点**：注意！从 MDR 读进来的数据，只能走 **B 口** (参考上一问的分析)，不能走 A 口。
    

---

##### 4. 主存 $\rightarrow$ 主存 (最麻烦的情况)
![[Pasted image 20251229152859.png]]
- **场景**：比如 `MOV (R0), (R1)` (把内存 A 处的数据搬到内存 B 处)。
    
- **难点**：模型机是单总线，而且 MDR 只有一个。你不能同时“读”又“写”。必须先把读出来的数找个地方存着，腾出 MDR，再把数放回去写。
    
- **路径** (课件 P49)：
    
    1. **读出暂存**：$M \rightarrow MDR \rightarrow B \rightarrow ALU \rightarrow ... \rightarrow C$ (暂存器) 6
        
        - _解释_：先把源数据读出来，放在 **暂存器 C** 里保护起来。
            
    2. **送回 MDR**：$C \rightarrow A/B \rightarrow ALU \rightarrow ... \rightarrow MDR$ 7
        
        - _解释_：现在准备写了，把 C 里的数据搬回 MDR。
            
    3. **写入内存**：$MDR \rightarrow 数据总线 \rightarrow M$ 8
        
- **关键点**：**暂存器 C** 在这里立了大功，充当了中转站。这也是为什么这类指令执行最慢（访存2次，内部倒手好几次）。
    

---

##### 5. 寄存器 $\rightarrow$ 外设 (I/O 输出)
![[Pasted image 20251229152917.png]]
- **前提**：模型机采用**统一编址**（把外设当内存看）。
    
- 路径 (课件 P50)：
    
    与 “2. 寄存器 $\rightarrow$ 主存” 完全相同！9
    
    - $R_i \rightarrow ... \rightarrow MDR \rightarrow I/O接口$
        
- **关键点**：因为是统一编址，CPU 觉得它只是在往一个“特殊的内存地址”写数据而已。
    

---

##### 6. 外设 $\rightarrow$ 寄存器 (I/O 输入)
![[Pasted image 20251229153003.png]]
- **前提**：统一编址。
    
- 路径 (课件 P51)：
    
    与 “3. 主存 $\rightarrow$ 寄存器” 完全相同！10
    
    - $I/O接口 \rightarrow MDR \rightarrow ... \rightarrow R_i$
        

---

##### ⚡ 总结一下核心规律

看完这 6 种，其实你只需要记住 **3 条铁律**，就能推导出所有路径：

1. **MDR 是海关**：凡是跟**外部**（内存或 I/O）打交道，数据必须经过 MDR。
    
2. **C 是中转站**：凡是**内存搬内存**（M to M），中间必须用 C 暂存。
    
3. **ALU 是必经之路**：凡是内部传送，都要经过 `A/B -> ALU -> 移位器 -> 总线` 这一套流程。
    

现在这 6 种情况是不是逻辑分明了？考试时如果让你画 **Mem to Mem** 的路径，千万别忘了中间那个 **C** 哦！
        

### 3. 微命令设置 (Micro-commands) —— 控制信号

这部分讲的是“谁来控制开关”。为了实现上述通路，控制逻辑需要发出四类微命令：

1. **ALU 输入选择**：决定谁送给 A 口（`Ri->A`），谁送给 B 口（`Rj->B`）。
    
2. **ALU 功能选择**：加、减、直传等（$S_0-S_3, M, C_0$）。
    
3. **移位器控制**：直传（DM）、左移（SL）、右移（SR）。
    
4. **寄存器打入脉冲**：决定数据什么时候真正写入寄存器（如 `CPR0`, `CPPC`）。
    
5. **系统接口控制**：`EMAR`（允许 MAR 输出地址）、`R/W`（读写控制）。
    

---

### 🎓 复习总结：如何应对考试？

这一节的学习策略是 **“图文结合”**：

1. **死磕 P32 数据通路图**：
    
    你需要能看着这张图，用手指划出 `MOV (R0), R1` 这种指令的每一步数据流向。如果能划通，这节就掌握了 80%。
    
2. **理解“暂存器 C 和 D”的作用**：
    
    - **考点**：为什么变址寻址时，从内存读出的偏移量要先存到 **C** 里？
        
    - _答案_：因为 ALU 有两个入口（A和B），一个入口接了变址寄存器 $R_X$，另一个入口必须接这个偏移量。但数据总线来的数据不能直接挂在 ALU 入口上，必须先暂存到 C，才能和 $R_X$ 一起进入 ALU 进行加法运算。
        
3. **区分“地址”和“数据”**：
    
    - **考点**：`MAR` 里的东西是要送到**地址总线**的；`MDR` 里的东西是来自/去往**数据总线**的。千万别搞混。
        

这一节虽然逻辑复杂，但一旦你理解了“单总线”这个交通规则，剩下的就是按部就班的搬运工作了。


## 四、主机与外部的数据通路与信息传送控制方式


### 1. 硬件连接：大家怎么连在一起？

这部分讲的是物理拓扑结构，主要有三种模式：

- **辐射型（星型）**：
    
    - **特点**：CPU 像章鱼一样，每根触手单独连一个设备。
        
    - **优缺点**：速度快（专线专用），但线路太多，想加新设备很麻烦（不易扩展）。
        
- **总线型**：
    
    - **特点**：所有设备都挂在一根公共总线上 3。这是现代微机最常用的方式。
        
    - **优缺点**：结构简单，容易加设备（易扩展），但大家共用一条路，容易堵车（吞吐量有限，速度慢）。
        
- **通道型**：
    
    - **特点**：引入了一个“小 CPU”叫**通道**来专门管 I/O。
        
    - **优缺点**：并行能力强，主机不用操心琐事，常用于大型机。
        

---

### 2. 控制方式：数据怎么传？（**⭐ 绝对重点**）

这部分讲的是 CPU 和外设的“协作模式”，从低级到高级一共三种：

#### ① 直接程序传送方式 (也叫“程序查询/轮询”)
![[Pasted image 20251229154022.png]]
- **核心逻辑**：CPU 是个“控制狂”，必须全程盯着。
    
- **流程**：CPU 不断查询外设状态（空闲？忙？结束？。
    
    - 如果外设在忙，CPU 就**原地等待**，啥也不干。
        
- **缺点**：CPU 利用率极低，大部分时间都在傻等（“踏步”），不能和外设并行工作。
    
- **适用**：只适合极低速的设备。
    

#### ② 程序中断方式 (Interrupt)

- **核心逻辑**：CPU 学会了“放权”。
    
- **流程**：
    
    1. CPU 启动外设后，**继续干自己的事**（并行）。
        
    2. 外设干完了，发一个信号（中断请求）叫 CPU。
        
    3. CPU **暂停**当前程序，保存现场（断点 PC、状态 PSW），转去执行“中断服务程序”来处理数据。
        
    4. 处理完后，恢复现场，继续刚才的工作。
        
- **关键点**：实现了 CPU 和外设的**并行**工作。适合处理随机事件和中低速 I/O。
    

#### ③ 直接存储器访问 (DMA) —— 速度之王

- **核心逻辑**：CPU 找了个“代理人”——**DMA 控制器**。
    
- **流程**：
    
    - CPU 只需要做一件事：**初始化**（告诉 DMA：传什么、从哪传、传多少）。
        
    - 剩下的数据传送完全由硬件（DMA 控制器）接管，直接在**内存和外设**之间搬运，**不经过 CPU**。
        
    - 传完了，DMA 再发个中断告诉 CPU 一声。
        
- **特点**：
    
    - CPU 在传送期间可以去忙别的（或者暂停一下让出总线），**不需要执行指令**来搬运数据。
        
    - 没有“保存现场/恢复现场”的麻烦，速度极快。
        
- **适用**：高速外设（如硬盘）的**批量数据**传送。
    

---

### ⚡ 考试必背对比表

| **控制方式** | **CPU 是否干预传送** | **数据经过 CPU 吗？** | **并行程度** | **适用场景**   |
| -------- | -------------- | --------------- | -------- | ---------- |
| **程序查询** | 是 (全程)         | 是 (经寄存器)        | 无 (串行)   | 极低速设备      |
| **中断**   | 是 (通过程序)       | 是 (经寄存器)        | 有 (并行)   | 随机事件，键盘/鼠标 |
| **DMA**  | **否** (硬件控制)   | **否** (直接入内存)   | 高 (并行)   | 硬盘等大数据块    |

重点提示：

考试特别喜欢问：“DMA 方式下，CPU 真的完全不管了吗？”

答案是：不是。CPU 负责初始化（开始前）和善后处理（结束后），只是中间最累的搬运工作甩手了。




## 五、时序控制方式与时序系统


### 1. 两种核心控制方式 (Control Methods) —— **⭐ 必考对比**

这是关于“大家听谁指挥”的问题：

- **同步控制 (Synchronous Control)** —— **像阅兵**
    
    - **特点**：所有部件都由统一的时钟信号控制。时间被划分为固定的**时钟周期**（节拍），每个动作必须在规定的节拍内完成。
        
    - **优点**：逻辑简单，容易设计。
        
    - **缺点**：必须迁就最慢的部件（木桶效应），时间利用率可能不高。
        
    - **应用**：通常用于 **CPU 内部** 的控制。
        
- **异步控制 (Asynchronous Control)** —— **像打电话**
    
    - **特点**：没有统一时钟，操作之间靠**“应答”**（握手信号）来衔接。
        
        - A 发出“请求” (Request) $\rightarrow$ B 完成后发回“响应” (Acknowledge) $\rightarrow$ A 再进行下一步。
            
    - **优点**：时间紧凑，效率高，能适应不同速度的设备。
        
    - **缺点**：控制逻辑复杂。
        
    - **应用**：通常用于 **总线**（连接不同速度的设备）或 **I/O 传输**。
        

### 2. 时序系统的层级 (Timing Hierarchy) —— **⭐ 概念辨析**

![[Pasted image 20251229154638.png]]
这是一个从大到小的时间单位划分，考试常考排序或定义辨析（课件 P88）：

1. **指令周期 (Instruction Cycle)**：**最大单位**。取出并执行完**一条指令**所需的全部时间。
    
2. **工作周期 (Machine/CPU Cycle)**：**中间单位**。指令执行过程中的某个阶段（如取指周期、执行周期）。
    
    - _注：一个指令周期包含若干个工作周期。_
        
3. **时钟周期 / 节拍 (Clock Cycle / Beat)**：**基本单位**。时序系统中最基本的时间段，通常由系统主频决定。
    
    - _注：一个工作周期包含若干个时钟周期。_
        
4. **定时脉冲 (Pulse)**：**最小单位**。用于触发动作的瞬间信号（如寄存器打入脉冲）。
    

层级关系总结：

**指令周期 $\supset$ 工作周期 $\supset$ 时钟周期 (节拍) $\supset$ 脉冲

### 3. 指令序列的衔接 (Instruction Linking) —— 了解即可

课件 P86 提到了三种方式，主要理解前两种：

- **串行**：一条执行完，才取下一条（简单但慢）。
    
- **重叠 (Overlap)**：上一条还在执行，下一条就开始取指了（流水线技术的雏形，速度快）13。
    

---

### 🧠 重点复习建议

1. **死记层级**：一定要背下来 **指令周期 > 工作周期 > 时钟周期** 这个大小关系。
    
2. **理解场景**：
    
    - 问：为什么 CPU 内部用同步？答：因为内部元件速度一致，同步设计简单可靠。
        
    - 问：为什么总线或 I/O 用异步？答：因为外设速度千差万别，异步能让快的不用等慢的。
        

到这里，第三章的第一大节“模型机总体设计”我们就全部梳理完了！从指令长什么样，到 CPU 肚子里有什么，再到数据怎么跑、时间怎么算，你已经建立了一个完整的 CPU 框架。

下一步计划：

这章后面还有关于 “算术逻辑运算部件（具体怎么算加减乘除）” 和 “控制器（怎么发微命令）” 的内容。