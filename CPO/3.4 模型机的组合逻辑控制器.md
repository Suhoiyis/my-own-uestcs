# 组合逻辑控制器概述

### 1. 定义与本质 (Definition)

- 什么是组合逻辑控制器？
    
    它的微命令（控制信号）是由组合逻辑电路产生的。
    
- **构成**：针对每一个微命令（比如 `Mov`, `Add`），都设计一组专门的逻辑电路。全机所有的这些电路集合在一起，就构成了**微命令发生器**。
    
- **通俗理解**：就像是一个复杂的电路开关网络，输入一变，输出立马跟着变。
    

### 2. 硬件组成框图 (Hardware Composition) —— **⭐ 核心考点**

请重点看 **PPT 第 5 页** 的框图，这是理解它如何工作的关键。
![[Pasted image 20251229161429.png]]
你可以把它看作一个**黑盒子（微命令发生器）**，我们需要关注它的**输入（依据）**和**输出（命令）**：

#### **输入端（三大依据）：**

1. **指令信息**（来自 **IR**）：
    
    - **操作码**：经**译码器**翻译，告诉控制器“要做什么”（如加法、传送）。
        
    - **寻址方式**：告诉控制器“数据在哪里”。
        
2. **时序信号**（来自 **时序系统**）：
    
    - 提供时间基准（周期、节拍、脉冲），告诉控制器“什么时候做”。
        
3. **状态信息**（来自 **PSW** 和外部）：
    
    - **PSW**：反映 CPU 内部状态（如是否溢出、是否为负）。
        
    - **I/O 与控制台**：反映外部设备的状态（如是否有中断请求。
        

#### **内部处理部件：**

- **地址形成部件**：结合指令中的地址码和寻址方式，计算出操作数的**有效地址**，或者转移指令的**跳转地址**。
    

#### **输出端：**

- **微命令序列**：也就是我们在上一节学过的那些 `PC->A`, `EMAR`, `R/W` 等信号，直接控制各个硬件部件。
    

### 3. 工作原理 (Working Principle)

课件 **P6-P7** 描述了它的动态工作过程：

1. **取指**：指令从主存取出，放入 **IR**（指令寄存器）。
    
2. **分析**：
    
    - 操作码 $\rightarrow$ 译码器 $\rightarrow$ 逻辑信号。
        
    - 地址码 $\rightarrow$ 地址形成部件 $\rightarrow$ 实际地址（去访存或找寄存器）。
        
3. **综合决策**：
    
    - **微命令发生器** 综合 **“指令内容 + 状态标志 + 当前时间”**，通过逻辑电路，实时发出微命令。
        
4. **执行与跳转**：
    
    - 如果是顺序执行，PC 自动 +1。
        
    - 如果是转移指令，地址形成部件算出目标地址送入 PC。
        

---

### 🧠 总结

对于这一节，你只需要记住**组合逻辑控制器**的本质公式：

$$\text{微命令} = F(\text{指令操作码}, \text{时序信号}, \text{状态标志})$$

它就像一个**反应极快**的反射弧：眼睛（IR）看到指令，耳朵（时序）听到节奏，身体（PSW）感觉状态，大脑（组合逻辑）立刻发出电信号指挥肌肉（微命令）。



# 组合逻辑控制器时序系统

它揭示了组合逻辑控制器是如何通过**“三级时序”**来精准控制每一个微小动作的。

简单来说，控制器的时间管理就像一个**层层嵌套**的俄罗斯套娃：最外层是“工作阶段”，中间层是“节拍”，最核心层是“脉冲”。

以下是这三级时序系统的详细解构：

### 1. 第一级：工作周期 (Working Cycle) —— 宏观阶段

这是最大的时间单位，标志着 CPU 当前处于指令执行的哪个**大阶段**。

模型机定义了 **6 种** 工作周期状态，并用 **6 个触发器** 来标记（同一时间只有一个为 1）：

- **指令执行类（4种）：**
    
    1. **取指周期 (FT, Fetch)**：公共操作，所有指令都要经历，从内存取出指令。
        
    2. **源周期 (ST, Source)**：如果指令需要从内存取**源操作数**（非寄存器寻址），就进入这个周期。
        
    3. **目的周期 (DT, Destination)**：如果指令需要从内存取**目的操作数/地址**，就进入这个周期。
        
    4. **执行周期 (ET, Execute)**：拿到数据后，真正执行运算的阶段。这是所有指令的最后一步。
        
- I/O 控制类（2种）：
    
    5. 中断周期 (IT, Interrupt)：用于响应和处理中断请求的过渡期。
    
    6. DMA 周期 (DMAT)：响应 DMA 请求，CPU 让出总线控制权
    

**🔄 状态转换流程（必考图解 P10）：**
![[Pasted image 20251229161939.png]]

- **正常流程**：`FT` $\rightarrow$ (如果有源操作数) `ST` $\rightarrow$ (如果有目的操作数) `DT` $\rightarrow$ `ET`。
    
- **结束检查**：`ET` 结束后，CPU 会先看有没有 **DMA 请求**？有则去 `DMAT`。再看有没有 **中断请求**？有则去 `IT`。都没有才回到 `FT` 开始下一条指令。
    

### 2. 第二级：时钟周期 / 节拍 (Clock Cycle) —— 基本步调

- **定义**：这是 CPU 操作的基本时间单位。
    
- **设定**：为了简化控制，模型机把时钟周期的宽度设定为与**主存访问周期**一致（例如 1 微秒）。
    
- **作用**：在一个时钟周期内，CPU 可以完成一步独立的数据通路操作（比如“寄存器A送到ALU算一下再送回B”）。
    

### 3. 第三级：工作脉冲 (Working Pulse, P) —— 精准触发

这是最小的时间单位，通常出现在每个时钟周期的**末尾**。它像发令枪一样，确动作的“生效”时刻。

- **前沿（上升沿）**：**打入寄存器**。标志着这一拍的数据运算结束了，把结果稳定地写入寄存器。
    
- **后沿（下降沿）**：**时序转换**。
    
    - 如果本周期还没完，就让计数器 T 加 1，进入下一个节拍。
        
    - 如果本周期完了，就清零 T，切换到下一个工作周期（比如从 FT 切到 ST）。
        

---

### 🧠 总结：三级时序是如何配合的？

想象 CPU 在做一道菜（执行指令）：

1. **工作周期** 是“步骤”：现在是“切菜阶段”（FT），还是“炒菜阶段”（ET）。
    
2. **时钟周期** 是“动作”：切菜阶段里，切第一刀（T0）、切第二刀（T1）。
    
3. **工作脉冲** 是“落刀”：每一刀切下去的那一瞬间（脉冲 P），菜才算切开了（数据写入）。
    

这种**分级控制**保证了 CPU 既有宏观的流程条理，又有微观的精准同步。这就是组合逻辑控制器“硬布线”背后的时间逻辑。



# 指令流程与操作时间表

### 1. 两个描述层次：从“做什么”到“怎么做”

课件首先明确了描述指令执行过程的两个维度 1：

- **第一层：指令流程 (Instruction Flow)**
    
    - **含义**：**“做什么”**。在寄存器级描述数据怎么流。
        
    - _例子_：`PC -> MAR`（把 PC 的值送到地址寄存器）。
        
- **第二层：操作时间表 (Operation Time Table)**
    
    - **含义**：**“怎么做”**。把上面的流程分配到具体的**时钟周期 (T)** 中，并列出需要的**微命令**。
        
    - _例子_：在 $T_0$ 时刻，发出 `PC->A`, `A->B`, `ALU直传`, `EMAR` 等电平信号，并在末尾发 `CPMAR` 脉冲。
        

---

### 2. 分周期深度解析：CPU 的“四步走”

![[Pasted image 20251229163044.png]]

这部分占据了课件的绝大多数篇幅，按**工作周期**的顺序详细列出了各种情况的操作表。

#### 1. FT：取指周期 (Fetch Time) —— “接单”

- **地位**：**雷打不动的起点**。任何指令的执行都必须从这里开始。
    
- **核心任务**：
    
    1. **取指令**：根据 PC 的地址，去内存把指令搬到 IR（指令寄存器）里。
        
    2. **更新 PC**：`PC + 1`，指向下一条指令。
        
    3. **译码与判决**：这是 FT 结束时的关键动作。控制器分析 IR 里的指令：
        
        - 如果是单操作数指令（如 `INC R0`）且操作数在寄存器 $\rightarrow$ 直接跳去 **ET**。
            
        - 如果有源操作数在内存（如 `ADD (R0), ...`） $\rightarrow$ 决定下一站去 **ST**。
            
        - 如果源在寄存器，但目的在内存 $\rightarrow$ 跳过 ST，直接去 **DT**。
            

#### 2. ST：源周期 (Source Time) —— “取原材料”

- **地位**：**选修课**。只有当**源操作数 (Source)** 在**内存**里时，才进入这个周期。
    
- **判断标准**：看指令的**源寻址方式 (SR)**。
    
    - **跳过 ST**：如果源是寄存器寻址（如 `ADD R0, R1` 中的 `R1`），数据已经在 CPU 肚子里了，不需要去内存取，直接跳过。
        
    - **进入 ST**：如果源是间接寻址 `(R)`、变址 `X(R)` 等，说明数据在内存。
        
- **核心任务**：
    
    - 算出源操作数的有效地址。
        
    - 从内存读出操作数，通常暂存在 **C 寄存器** 中（因为 MDR 只有一个，要腾出来给后面用）。

##### 第一类：基础型（2 个节拍）

这类寻址方式最快，因为地址几乎是现成的，不需要复杂的计算。

###### 1. **寄存器间接寻址 `(R)`**
![[Pasted image 20251229163711.png]]
- **逻辑**：寄存器 $R_i$ 里存的就是地址，直接拿来用。
    
- **流程（2T）**:
    
    - **$ST_0$ (送地址)**：把 $R_i$ 的内容直接送到 **MAR**。
        
        - 微操作：$R_i \rightarrow MAR$。
            
    - **$ST_1$ (取数)**：内存读出数据，经过 MDR，**暂存在 C** 中。
        
        - 微操作：$M \rightarrow MDR \rightarrow C$。
            
- **特点**：最标准的操作，没有额外计算。
    

###### 2. **自减型寄存器间址 `-(R)`**
![[Pasted image 20251229163737.png]]
- **逻辑**：**先减后用**。先把寄存器值减 1，再作为地址。
    
- **流程（2T）**:
    
    - **$ST_0$ (减 1 并送地址)**：这是并行操作的典范。数据经过 ALU 时减 1，**同时**送回 $R_i$（更新）和 **MAR**（做地址）。
        
        - 微操作：$R_i - 1 \rightarrow R_i, MAR$。
            
    - **$ST_1$ (取数)**：同上，读入 C。
        
- **特点**：虽然有减法，但利用硬件并行性，**没有增加额外时间**，依然是 2 拍。
    

---

##### 第二类：后处理型（3 个节拍）

这类寻址方式多了一个“善后”动作。

###### 3. **自增型寄存器间址 `(R)+`**
![[Pasted image 20251229163756.png]]
- **逻辑**：**先用后加**。先用旧值做地址，用完了再加 1。
    
- **流程（3T）**:
    
    - **$ST_0$ (送旧地址)**：把 $R_i$ 原封不动送到 **MAR**。
        
    - **$ST_1$ (取数)**：读出数据存入 C。
        
    - **$ST_2$ (修正寄存器)**：这是多出来的一步。ALU 计算 $R_i + 1$，结果写回 $R_i$。
        
        - 微操作：$R_i + 1 \rightarrow R_i$。
            
- **特点**：因为必须等地址送出后才能修改寄存器，所以“加 1”动作被迫放到了第 3 拍。
    

---

##### 第三类：复杂计算型（5 个节拍）

这类寻址方式需要多次访问内存或进行复杂的地址合成，是 CPU 的“体力活”。

###### 4. **变址寻址 `X(R)`**

![[Pasted image 20251229164036.png]]![[Pasted image 20251229164043.png]]
- **逻辑**：有效地址 = **寄存器内容 $R_i$ + 形式地址 X**。
    
    - _注意_：形式地址 X 是指令的一部分，跟在操作码后面，所以要用 **PC** 去取它。
        
- **流程（5T）**:
    
    +1
    
    - **$ST_0$ (找 X 的地址)**：把 **PC** 送到 MAR。
        
    - **$ST_1$ (取 X)**：从内存读出 X，**暂存在 C** 中。
        
    - **$ST_2$ (PC+1)**：PC 加 1，指向下一条指令（为下一次取指做准备）。
        
    - **$ST_3$ (算有效地址)**：把 C (即 X) 和 $R_i$ 送入 ALU 相加，结果送入 **MAR**。
        
        - 微操作：$R_i + C \rightarrow MAR$。
            
    - **$ST_4$ (取数)**：终于拿到真正的操作数，存入 C。
        
- **特点**：涉及 **PC 操作**、**取偏移量**、**ALU 计算**，非常繁琐。
    

###### 5. **自增型双重间址 `@(R)+`**
![[Pasted image 20251229164104.png]]![[Pasted image 20251229164118.png]]![[Pasted image 20251229164135.png]]
- **逻辑**：**套娃**。$R_i$ 指向内存 A，内存 A 里存着地址 B（这是第一次取），然后去地址 B 取数（第二次取）。最后 $R_i$ 还要加 1。
    
- **流程（5T）**:
    
    +1
    
    - **$ST_0$ (送指针地址)**：$R_i \rightarrow MAR$。
        
    - **$ST_1$ (取间接地址)**：读出“地址的地址”，**暂存在 C** 中。
        
    - **$ST_2$ (修正寄存器)**：$R_i + 1 \rightarrow R_i$。
        
    - **$ST_3$ (送有效地址)**：把刚才取到的 C 送入 **MAR**。
        
    - **$ST_4$ (取数)**：拿到最终操作数，存入 C。
        
- **特点**：典型的**两次访存**操作。
    

---

##### ⚡ 总结对比表

|**寻址方式**|**节拍数**|**关键差异点**|**为什么？**|
|---|---|---|---|
|**(R)**|**2**|直接送址|地址现成，取了就走|
|**-(R)**|**2**|并行减法|ALU 算减法的同时送地址，不耽误时间|
|**(R)+**|**3**|**后加**|先送地址取数，最后专门花一拍来 +1|
|**X(R)**|**5**|**PC 取数 + 计算**|偏移量在指令里，要先用 PC 取出来，再和 R 相加|
|**@(R)+**|**5**|**两次访存**|先取地址，再取操作数，中间还要 +1|

**核心规律**：

- 凡是涉及 **PC**（如变址）或 **双重间接** 的，都要 **5 个节拍**。
    
- 凡是 **自增** `(R)+` 的，都比普通的 **多 1 个节拍**（用于善后）。
    
- **自减** `-(R)` 因为是预处理，反而不增加节拍。


#### 3. DT：目的周期 (Destination Time) —— “确认收货地”

- **地位**：**选修课**。只有当**目的操作数 (Destination)** 在**内存**里时，才进入这个周期。
    
- **判断标准**：看指令的**目的寻址方式 (DR)**。
    
    - **跳过 DT**：如果结果是存回寄存器（如 `ADD R0, R1` 中的 `R0`），直接跳过。
        
    - **进入 DT**：如果结果要存回内存（如 `MOV (R0), R1` 中的 `(R0)`）。
        
##### DT 的核心任务：计算地址 + (可选)取数

这是 DT 与 ST 最大的不同点。在 ST 中，我们总是要把数取回来的。但在 DT 中，取决于指令的操作类型（MOV 还是 ALU 运算），任务有微妙的区别 2：

###### **情况 A：传送类指令 (如 `MOV (R0), R1`)**

- **任务**：**只算地址，不取数**。
    
- **逻辑**：要把 R1 的值覆盖写入到 (R0) 指向的内存里。所以我只需要把 (R0) 的地址算出来放到 **MAR** 里准备好就行了。没必要把内存里原来的旧值读出来（反正马上要被覆盖）。
    
- _流程_：算出有效地址 $\rightarrow$ 送入 **MAR** $\rightarrow$ 结束 DT。
    

###### **情况 B：运算类指令 (如 `ADD (R0), R1`)**

- **任务**：**算地址 + 取回旧值**。
    
- **逻辑**：要把 (R0) 内存里的数和 R1 相加。所以我不仅要算地址，还必须把 (R0) 里的**旧值读出来**，暂存在 **D 寄存器** 中，等待在 ET 周期和 R1 进行加法运算。
    
- _流程_：算出有效地址 $\rightarrow$ 送入 **MAR** $\rightarrow$ 读内存 ($M \rightarrow MDR$) $\rightarrow$ **暂存到 D**。
    

---
        

#### 4. ET：执行周期 (Execute Time) —— “加工与结单”



##### 1. ET 的核心分类逻辑

课件 **P25** 定义了两个关键符号：
![[Pasted image 20251229164428.png]]
- **SR (Source Register)**：源操作数在**通用寄存器**中。
    
- **DR (Destination Register)**：目的操作数在**通用寄存器**中。
    

如果不是 SR 或 DR，就意味着操作数在**主存 (Memory)** 中（需要通过 MAR/MDR 访问）。

---

##### 2. 四种剧情的详细拆解

![[Pasted image 20251229164644.png]]

###### **剧情一：SR · DR（寄存器 $\to$ 寄存器）—— 最快**

![[Pasted image 20251229164656.png]]
- **场景**：`MOV R0, R1` 或 `ADD R0, R1`。
    
- **状态**：源数据在 $R_i$，目的在 $R_j$。都不涉及主存。
    
- **流程（1 个节拍）**：
    
    - **$ET_0$**：数据直接通过 ALU 流过去。
        
        - **动作**：$R_i \rightarrow ALU \rightarrow R_j$（如果是 ADD，就是 $R_i + R_j \rightarrow R_j$）。
            
- **特点**：**秒杀**。因为不出 CPU 内部，速度极快。
    

###### **剧情二：SR · !DR（寄存器 $\to$ 主存）—— 写内存**

![[Pasted image 20251229164735.png]]

- **场景**：`MOV (R1), R0`（把 R0 的值存入 R1 指向的内存）。
    
- **状态**：
    
    - 源数据在 $R_i$（寄存器）。
        
    - 目的地址已经在 DT 周期算好，放在 **MAR** 里了。
        
- **流程（2 个节拍）**：
    
    - **$ET_0$ (填数据)**：把寄存器的数据搬到 **MDR**（因为 MDR 是去内存的必经之路）。
        
        - **动作**：$R_i \rightarrow MDR$。
            
    - **$ET_1$ (写内存)**：向内存发“写”命令。
        
        - **动作**：$MDR \rightarrow Memory$ (微命令：EMAR, W)。
            
- **特点**：因为涉及写内存，必须经过 MDR，多耗一拍。
    

###### **剧情三：!SR · DR（主存 $\to$ 寄存器）—— 读后处理**

![[Pasted image 20251229164757.png]]
- **场景**：`MOV R0, (R1)`（把 R1 指向的内存数读到 R0）。
    
- **状态**：
    
    - 源数据在 **ST 周期** 已经被读出来，暂存在 **C 寄存器** 里了（这是关键！）。
        
    - 目的在 $R_j$（寄存器）。
        
- **流程（1 个节拍）**：
    
    - **$ET_0$**：把暂存器 C 里的货拿出来处理。
        
        - **动作**：$C \rightarrow ALU \rightarrow R_j$（如果是 ADD，就是 $C + R_j \rightarrow R_j$）。
            
- **特点**：虽然源在内存，但因为 ST 周期已经把它搬进来了，所以在 ET 阶段和“寄存器对寄存器”一样快。
    

###### **剧情四：!SR · !DR（主存 $\to$ 主存）—— 最慢/最复杂**

![[Pasted image 20251229164823.png]]
- **场景**：`ADD (R0), (R1)`（内存加内存，结果回写内存）。
    
- **状态**：
    
    - 源数据：在 ST 周期取回，在 **C** 里。
        
    - 目的数据（旧值）：在 DT 周期取回，在 **D** 里。
        
    - 目的地址：在 **MAR** 里。
        
- **流程（2 个节拍）** 4：
    
    - **$ET_0$ (计算并填装)**：ALU 运算，结果送入 MDR。
        
        - **动作**：$C + D \rightarrow ALU \rightarrow MDR$。
            
    - **$ET_1$ (写回)**：把运算结果写入内存。
        
        - **动作**：$MDR \rightarrow Memory$ (微命令：EMAR, W)。
            
- **特点**：这是 CPU 的“高光时刻”，C 和 D 两个暂存器同时由 ALU 处理，最后写回内存。
    

---

##### 3. ET 也是“特殊指令”的家

除了上面的加减传送，ET 还负责处理其他特殊指令：

- **单操作数指令 (如 `INC (R0)`)** ：
    
    - 逻辑同剧情四。先在 DT 取数到 MDR/D，ET 阶段做 $D+1 \rightarrow MDR \rightarrow Memory$。
        
- **转移指令 (JMP)** ：
    
    - ET 负责把计算好的跳转地址送入 **PC**。
        
- **转子/中断返回 (JSR/RST)** ：
    
    - 涉及到**堆栈操作**。ET 阶段会把 PC 的值（断点）写入 SP 指向的内存（压栈）。这里 SP 会充当 MAR 的角色。
        

---

##### 4. ET 的最后一步：收尾检查 (Check Point)

不管走了哪种剧情，在 ET 的最后一个节拍末尾（例如 $ET_1$ 或 $ET_0$），控制器都会发出**询问信号** 8888：

+1

1. **"有 DMA 请求吗？" (1->DMAT?)**
    
    - 如果有，下一拍进入 **DMAT 周期**（把总线让给硬盘去传数据）。
        
2. **"有中断请求吗？" (1->IT?)**
    
    - 如果有，下一拍进入 **IT 周期**（去处理键盘鼠标的点击）。
        
3. **"都没有？"**
    
    - 下一拍回到 **FT**（取指周期），继续搬砖，执行下一条指令。
        

##### ⚡ 总结：ET 的一句话口诀

**“内对内一拍完，涉外写多一拍；C 和 D 来帮忙，最后别忘查中断。”**

- **内对内**：寄存器到寄存器，1 个 $T$。
    
- **涉外写**：只要结果存内存，就要经过 MDR，2 个 $T$。
    
- **C/D**：内存取来的数，ET 阶段是从 C 或 D 里拿的。
    
- **查中断**：ET 结束是 CPU 切换任务的唯一窗口期。
    

---

### 3. 核心案例分析：一张“大表”看懂所有

课件 **P36-P41** 用一个极其复杂的指令为例，完整展示了全过程。建议你死磕这个例子，它是这一章的**集大成者**：

**指令**：`ADD @(R1)+, X(R3)`

- **含义**：源操作数用变址寻址 `X(R3)`，目的操作数用双重间接自增 `@(R1)+`，做加法。
    
- **执行剧本**：
    
    1. **FT (3拍)**：取指令。
        
    2. **ST (5拍)**：处理源 `X(R3)`。
        
        - 取偏移量 X $\rightarrow$ 算地址 $\rightarrow$ 取源操作数 $\rightarrow$ **暂存到 C**。
            
    3. **DT (5拍)**：处理目的 `@(R1)+`。
        
        - 取间址 $\rightarrow$ 取目的操作数 $\rightarrow$ **暂存到 D** $\rightarrow$ $R_1$ 自增。
            
    4. **ET (3拍)**：执行加法。
        
        - $C(源) + D(目的) \rightarrow MDR$ $\rightarrow$ 写回内存。
            

**你看，一条汇编指令，在 CPU 内部竟然被拆解成了 3+5+5+3 = 16 个时钟周期！** 这就是为什么复杂寻址方式慢的原因。

---

### 💡 复习建议

这一节不需要你背下所有表格（那是不可能的），但你需要掌握**“推导能力”**：

1. **看懂符号**：看到 `PC -> A` 知道是 PC 走 ALU 的 A 口。
    
2. **区分脉冲与电平**：
    
    - **电平型微命令**（如 `A/B`, `DM`）：在整个节拍内有效，负责“修路”（打通数据通路）。
        
    - **脉冲型微命令**（如 `CPMAR`, `CPPC`）：在节拍末尾有效，负责“临门一脚”（打入数据）。
        
3. **会画流程**：考试可能会给你一条简单的指令（如 `MOV (R0), R1`），让你模仿 PPT 写出它的 FT、ST、DT、ET 流程表。