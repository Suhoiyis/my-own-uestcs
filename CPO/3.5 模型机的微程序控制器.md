
# 01. 基本概念及原理

### 1. 五个核心概念 (The "Big 5" Definitions)

理解微程序控制器，必须先搞懂这 5 个名词的定义，它们是从小到大层层递进的：

1. **微命令 (Micro-command)** —— **最小单位**
    
    - **定义**：构成控制信号序列的最小单位。
        
    - **本质**：就是直接作用于硬件的**电信号**。比如“打开 ALU 的 A 口”、“打入 PC 寄存器” 。
        
    - _比喻_：像是指挥官喊出的“开火！”、“前进！”。
        
2. **微操作 (Micro-operation)**
    
    - **定义**：由微命令控制实现的具体操作。
        
    - **例子**：微命令是“打开门”，微操作就是“数据流过去了” 。通常这两个词通用。
        
3. **微指令 (Micro-instruction)** —— **一步操作的集合**
    
    - **定义**：在一个**微周期**（通常是一个时钟周期）内，所有并行执行的微命令的集合。
        
    - **存储**：它们一条条地存放在**控制存储器 (Control Memory, CM)** 里，每一行就是一个微指令。
        
    - _比喻_：像是菜谱里的一行步骤：“切菜的同时烧水”。
        
4. **微周期 (Micro-cycle)**
    
    - **定义**：从控制存储器读出一条微指令并执行完这一步所需的时间。
        
    - **关系**：通常 **1 个微周期 = 1 个时钟周期**。
        
5. **微程序 (Micro-program)** —— **最大的集合**
    
    - **定义**：一系列微指令的**有序集合**。
        
    - **作用**：**一个微程序 对应 一条机器指令**。
        
    - _比喻_：这一整页菜谱（微程序）就是为了做出一道菜（机器指令）。
        

---

### 2. 层级对应关系 (Hierarchy) —— **⭐ 核心考点**

请务必死记硬背这个“套娃”关系（课件 P6 7）：
![[Pasted image 20251229170913.png]]
- **1 条机器指令** (如 `MOV`, `ADD`) $\longleftrightarrow$ **1 段微程序**
    
- **1 段微程序** $\longleftrightarrow$ **N 条微指令** (取决于需要几个节拍)
    
- **1 条微指令** $\longleftrightarrow$ **N 个微命令** (取决于这一拍要干多少事)
    

举个例子（参考课件 P7）：

假设执行 MOV (R1), (R0) 这条机器指令：

- 它需要经过 FT、ST、DT、ET 四个周期。
    
- 这整个过程就是一个**微程序**。
    
- 其中在 $ST_1$ 这一拍，要做 `M -> MDR -> C`，这就是一条**微指令**。
    
- 而为了完成这一拍，硬件发出了 `EMAR`, `R`, `DM`, `CPC` 等信号，这些单独的信号就是**微命令** 8。
    

---

### 3. 微程序控制的核心思想 (Core Philosophy)

为什么我们要发明这个东西？（课件 P8）

- **存储逻辑 (Storage Logic)**：
    
    - 把控制信号编码成数据（微指令），**存**在 ROM（控制存储器）里。
        
    - 执行机器指令，就像是**查表**，根据指令码找到对应的微程序入口，然后一条条读出来执行。
        
- **程序技术引入硬件**：
    
    - 设计 CPU 不再是单纯的画电路图，而是变成了“写微代码”。
        
    - **优点**：如果想加新指令，只需要改写 ROM 里的微程序，不需要重新焊电路！
        

---

### 🧠 总结

- **组合逻辑控制器** = **硬连线** = 反应快但设计难，改动几乎不可能。
    
- **微程序控制器** = **存储逻辑** = 查表执行，速度稍慢但规整灵活。


# 二、微程序控制的概念

这一节（**课件 P8-P12**）是微程序控制器的核心，解释了它“为什么能工作”以及“肚子里有什么”。

简单来说，微程序控制的核心思想就是**“把硬件设计变成软件编程”**。

### 1. 核心思想 (Core Concept)

课件 **P8** 极其精炼地总结了微程序控制的两个本质特征 ：

1. **引入存储逻辑**：
    
    - 以前的控制器（组合逻辑）是靠电路的物理连接来产生信号。
        
    - 现在的控制器是把微命令变成 **0/1 代码（微码）**，**存**在 ROM（控制存储器）里。
        
2. **引入程序技术**：
    
    - 执行一条机器指令，不再是纯硬件的反射，而是去执行一段 **“微程序”**（由若干条微指令组成）。
        
    - 这使得 CPU 的设计从“焊电路”变成了“写代码”。
        

---

### 2. 硬件组成 (Hardware Composition) —— **⭐ 必考图解**

请重点看 **PPT 第 9 页** 的框图，这是微程序控制器的心脏。我们需要认识以下 **4 个关键部件** ：
![[Pasted image 20251229171213.png]]
#### **① 控制存储器 (CM, Control Memory)**

- **地位**：核心中的核心。
    
- **作用**：用来存放**微程序**。
    
- **特点**：通常由 **ROM**（只读存储器）构成，因为微程序是出厂就写好的，不需要经常改 。
    

#### **② 微指令寄存器 (uIR, Micro-Instruction Register)**

- **作用**：用来存放**当前正在执行**的那一条微指令。
    
- **结构**（P10）：它被分成了两半 ：
    ![[Pasted image 20251229171245.png]]
    - **微命令字段**：存放控制信号（如 `PC->A`, `Read`）。直接送去控制硬件。
        
    - **顺序控制字段**（也叫下址字段）：存放**下一条**微指令的地址信息。
        

#### **③ 微地址寄存器 (uAR, Micro-Address Register)**

- **作用**：相当于微程序级的 "PC"。它永远指向 **CM** 中**下一条**要读取的微指令的地址 。
    

#### **④ 微地址形成电路**

- **作用**：大脑的导航员。它负责计算**下一条微指令在哪里**。
    
- **依据** ：
    
    - **指令操作码**（决定首条微指令在哪）。
        
    - **uIR 的顺序控制字段**（微指令自带的导航）。
        
    - **PSW 状态**（比如结果为 0 跳转，结果为负跳转）。
        

---

### 3. 工作原理 (Working Principle)

课件 **P12** 描述了它的动态过程，其实和 CPU 执行机器指令的过程非常像，只是层级更低 ：

1. **取微指令**：根据 uAR 的地址，从 CM 中读出一条微指令，送到 uIR。
    
2. **执行与控制**：
    
    - uIR 中的 **微命令字段** 直接发出电信号，指挥 ALU、寄存器干活。
        
    - uIR 中的 **顺序控制字段** 结合状态信息，送入微地址形成电路。
        
3. **算下一条地址**：微地址形成电路算出下一条微指令的地址，送入 uAR，准备下一轮循环。
    

---

### 🧠 总结

微程序控制器就像一个**“自动演奏钢琴”**：

- **CM** 是**乐谱纸带**（存储了所有动作）。
    
- **uAR** 是**读谱头**（指向当前读到哪一行）。
    
- **uIR** 是**机械臂**（读取当前指令，一手按琴键，一手卷纸带到下一行）。


# 三、微指令的编码方式

**核心问题**：微指令寄存器里的那些 `0` 和 `1`，到底代表什么意思？怎么把它们翻译成具体的微命令（开门/关门）？

课件 **P13-P14** 介绍了三种主要方式：

#### 1. 直接控制法 (Direct Control) —— “开关阵列”

- **原理**：**一位对应一个命令** 。
    
    - 例如：第 1 位是 `PC->A`，第 2 位是 `A->B`。
        
    - 如果这一位是 `1`，命令就有效；是 `0` 就无效。
        
- **特点**：简单直观，不需要译码器，速度最快。但**太浪费位宽**（如果有 100 个微命令，微指令就得有 100 位长，太胖了）。
    

#### 2. 分段直接编译法 (Segmented Direct Encoding) —— “分组译码”

这是最常用的折中方案 。

- **原理**：
    
    1. 把微指令分成若干个**小字段（Field）**。
        
    2. 把**互斥**的微命令（不可能同时出现的，比如 `A->B` 和 `C->B`）放在同一个字段里。
        
    3. 每个字段通过一个**译码器**翻译成微命令。
        
- **特点**：缩短了微指令长度，效率较高。
    

#### 3. 分段间接编译法 (Segmented Indirect Encoding) —— “套娃”

- **原理**：一个字段的含义，还需要由另一个字段来解释 。
    
- **特点**：虽然省空间，但太慢了（要两级翻译），很少用。



# 四、微程序的顺序控制方式

**核心问题**：执行完这一条微指令，下一条去哪里找？（相当于微程序版的 `PC` 逻辑）。

课件 **P15-P17** 将其分为两个阶段：

#### 1. 初始微地址的形成（入口在哪里？）

也就是怎么从机器指令跳转到对应的微程序第一步。

- **取指阶段**：有一个固定的入口地址（通常是 0），这是所有指令的公用起点 。
    
- **功能转移**：取指完成后，根据 **IR 中的操作码 (Opcode)**，通过**微地址形成电路**（或者查 PLA 表），直接映射到该指令对应的微程序入口 。
    

#### 2. 后继微地址的形成（下一条在哪里？）

执行中间过程时，怎么找下一条？

- **增量方式 (Counter)**：类似 PC+1，顺序执行时直接 +1 。
    
- **断定方式 (Judgment)**：根据微指令中的**下址字段**，结合 **PSW 状态信息**（如进位、溢出）来决定跳转地址。这就是微程序里的 `if-else` 。



# 五、微指令格式


**核心问题**：一条微指令应该设计成多长？能干多少事？

课件 **P18-P20** 根据“并行能力”将其分为两大类：

#### 1. 垂直型微指令 (Vertical) —— “像机器指令”

- **定义**：一条微指令只能定义并执行**一种**基本操作 。
    
    - 例如：`MOV R0, R1` 这种。
        
- **特点**：
    
    - 短，简单，容易写。
        
    - 但**并行度低**，执行一条机器指令需要很多条垂直微指令，速度慢。
        
    - _例子_：`-(R)` 操作被拆成了很多步 。
        

#### 2. 水平型微指令 (Horizontal) —— “大力出奇迹”

- **定义**：一条微指令能同时定义并执行**多个并行**的基本操作 。
    
    - 例如：同时做 `M->IR`（取指） 和 `PC+1->PC`（计数）。
        
- **特点**：
    
    - 长（位宽大），复杂。
        
    - 但**并行度高**，效率极高，微程序短。
        
    - _例子_：FT 周期里，一行微指令就把取指和 PC+1 全干了
