
# 01. 中断基本概念


### 1. 核心定义 (Definition) —— 什么是中断？

**中断 (Interrupt)** 指的是：CPU 暂时停止现行程序的执行，转去执行为某个**随机事态**服务的中断处理程序。处理完毕后，**自动恢复**原程序的执行。

- **关键词**：
    
    - **暂时停止**：不是结束，还要回来的。
        
    - **随机事态**：不可预测的，比如键盘按下了、打印机没纸了。
        
    - **自动恢复**：像没发生过一样，继续做原来的事。
        

### 2. 实质与特点 (Essence & Characteristics)

#### **(1) 实质：程序切换 (Program Switching)**

中断的本质就是**CPU 从一个程序（主程序）跳到另一个程序（服务程序）去执行**。为了保证能跳回来，必须做两件事：

1. **保存断点 (Save Context)**：跳走之前，把当前执行到哪条指令（PC 值）和 CPU 的状态（PSW）存起来。
    
2. **恢复断点 (Restore Context)**：处理完后，把刚才存的东西取出来，恢复现场。
    

- **时机**：**一条指令完整结束时**。CPU 就像一个强迫症，必须把当前这条指令做完（比如把加法算完、结果写回寄存器），才肯去响应中断。
    

#### **(2) 特点：随机性 (Randomness)**

中断源什么时候发请求是不确定的。

- **真随机**：硬件故障、按键。
    
- **伪随机（有意调用）**：程序里写了“调用打印机”，虽然是程序安排的，但对 CPU 来说，打印机什么时候准备好也是未知的。
    

---

### 3. 中断的分类 (Classification) —— **⭐ 常考选择题**

课件 P6-P7 从不同维度对中断进行了分类：
![[Pasted image 20251229200005.png]]

|**分类维度**|**类别**|**说明**|**例子**|
|---|---|---|---|
|**中断源来源**|**内中断**|来自主机内部|运算溢出、除数为 0|
||**外中断**|来自主机外部|键盘输入、打印机就绪|
|**产生方式**|**硬件中断**|硬件信号触发|I/O 请求、故障|
||**软中断**|程序指令触发|`INT` 指令（系统调用）|
|**可否屏蔽**|**可屏蔽**|可以暂不理会|一般 I/O 请求|
||**非屏蔽**|必须立即响应|掉电、内存校验错|
|**入口获取**|**向量中断**|**硬件**提供入口地址|速度快，现代主流|
||**非向量**|**软件**查询入口|速度慢，早期使用|

---

### 4. 为什么要用中断？(Applications)

中断技术的出现是为了解决 CPU 和外设速度不匹配的问题，并赋予计算机处理突发事件的能力：

1. **管理中低速 I/O**：CPU 不用死等打印机（程序查询方式），打印机好了发个中断叫 CPU 就行。**并行程度大大提高**。
    
2. **处理故障**：电源掉电、运算溢出，必须靠中断紧急处理。
    
3. **实时处理**：工业控制中，传感器数据来了必须马上读，晚了就丢了。
    
4. **人机对话**：鼠标键盘的操作全是靠中断响应的。
    

---

### 🧠 总结

想象你在**打游戏（主程序）**：

1. **外卖小哥敲门（中断请求）**：这是**随机事件**。
    
2. 你打完这一局（**指令结束**），暂停游戏（**保护断点**）。
    
3. 去开门拿外卖（**中断服务程序**）。
    
4. 回来继续打游戏（**恢复断点**）。
    

如果敲门的是**推销员（可屏蔽中断）**，你可以假装听不见（**屏蔽**）；如果是**着火了（非屏蔽中断）**，你必须马上跑。


# 2. 中断请求过程（外部可屏蔽中断）


#### 1. 中断请求的产生 (Generation)

一个有效的“中断请求”并不是外设想发就发的，必须同时满足两个条件：

- **外设准备好了**：“完成”触发器置 `1`（表示数据已准备好或任务已完成）。
    
- **接口允许发送**：“屏蔽”触发器为 `0`（表示没有被屏蔽）。
    
- **结果**：这两个条件相“与”后，去置位 **“请求触发器”**，这就产生了一个待发送的请求信号。
    

#### 2. 中断请求的传送 (Transmission)

外设产生了请求，怎么传给 CPU？主要有三种连线方式：

- **单独请求线 (Separate Lines)**：每个设备拉一根线（$IREQ_0, IREQ_1 \dots$）直连 CPU。
    
    - _优点_：CPU 直接知道是谁。_缺点_：线太多，CPU 引脚不够用。
        
- **公共请求线 (Common Line)**：所有设备通过“或门”连到一根公共线（$INTR$）。
    
    - _优点_：省线。_缺点_：CPU 还要再查是谁发的。
        
- **二维结构**：像矩阵一样连接，兼顾了数量和识别速度。



# 3. 优先权逻辑与屏蔽技术


当多个中断同时发生，或者 CPU 正在忙更重要的事时，系统通过**判优**和**屏蔽**来控制局面。

#### 1. 优先权判优逻辑 (Priority Arbitration) —— “谁先来？”

当多个 `IREQ` 同时到来时，必须选出一个最重要的。判优可以由软件（查询顺序）做，也可以由硬件做。

**典型硬件判优方式：**

- **① 链式查询 (Daisy Chain) —— 串行排队**
    
    - **原理**：中断响应信号 `INTA` 像电流一样，从第 1 个设备串联传到第 N 个设备。
        
    - **规则**：如果第 1 个设备要中断，它就截获 `INTA`，不往下传；如果它不要，就往下传。
        
    - **特点**：**物理位置决定优先级**（离 CPU 越近越优先）。结构简单，但如果中间断了，后面全完。
        
- **② 中断控制器 (如 8259A) —— 集中管理**
    
    - **原理**：所有外设请求先发给 8259A，由它内部的逻辑电路（优先级裁决器 PR）迅速判断出最高优先级的请求，再转发给 CPU。
        
    - **特点**：**可编程**。可以通过指令改变优先级规则，非常灵活。
        

#### 2. 屏蔽技术 (Masking) —— “听不听？”

即使外设发出了最高优先级的请求，CPU 也可以选择“暂时不听”。这有两道门槛：

- **第一道门：CPU 级屏蔽 (IF 标志)**
    
    - **控制者**：CPU 自身状态寄存器 (PSW) 中的 **IF (Interrupt Flag)** 位 。
        
    - **操作**：
        
        - `IF=1` (开中断)：CPU 耳朵竖起来，可以响应外部中断。
            
        - `IF=0` (关中断)：CPU 捂住耳朵，除了非屏蔽中断外，谁叫也不理。
            
    - _场景_：在执行极其重要的原子操作（如保存现场）时，必须关中断。
        
- **第二道门：接口级屏蔽 (Mask Register)**
    
    - **控制者**：中断控制器 (8259A) 中的 **IMR (中断屏蔽寄存器)** 。
        
    - **操作**：可以单独屏蔽掉某一个具体的设备（比如只屏蔽打印机，但允许键盘）。
        
    - _场景_：想暂时忽略某个不紧急的设备。
        

---

### 🧠 8259A 内部核心部件总结 (必考点)

课件 P21 的 8259A 内部框图非常关键，请记住这三个寄存器 ：

1. **IRR (Interrupt Request Register)**：**请求寄存器**。记录哪些设备发来了请求（还没处理）。
    
2. **IMR (Interrupt Mask Register)**：**屏蔽寄存器**。记录哪些请求被人工屏蔽了。
    
3. **ISR (In-Service Register)**：**服务寄存器**。记录当前正在处理哪个中断（还没结束）。
    

**总结：**

- **判优**解决的是“多选一”的竞争问题。
    
- **屏蔽**解决的是“能不能打断”的控制问题。


# 4. 服务程序入口地址的获取方式


这一节 **5.4.4 服务程序入口地址的获取方式**（课件 P23-P38）解决了一个核心问题：**当 CPU 决定响应某个中断后，它怎么知道去哪里（内存的哪个地址）找这段处理代码？**

在早期的或者简单的系统中，可能会用软件查询（非向量中断），但在现代计算机中，几乎都采用**硬件向量中断**，因为快。

---

### 一、核心概念辨析 (Core Concepts)

#### 1. 向量中断 (Vector Interrupt) —— “查表法”

这是现代计算机的主流方式。

- **原理**：硬件直接产生一个指向服务程序的指针（向量地址），CPU 拿着这个指针去查表，就能找到服务程序的入口。
    
- **特点**：速度快，硬件实现。
    

#### 2. 非向量中断 (Non-Vector Interrupt) —— “问路法”

- **原理**：CPU 响应中断后，先跳到一个固定的通用处理程序，然后通过软件（查询程序）挨个问外设：“是你吗？”“是你吗？”，确定是谁后再跳去相应的服务程序。
    
- **特点**：硬件简单，但响应速度慢（软件查询耗时）。
    

---

### 二、向量中断的三大要素 (The Trinity of Vector Interrupts)

要理解向量中断，必须分清这三个词：

1. **中断向量 (Interrupt Vector)**：
    
    - 指的是**中断服务程序的入口地址**（有时也包含状态字 PSW）。
        
    - _比喻_：这是你要找的“具体的门牌号”。
        
2. **中断向量表 (Interrupt Vector Table, IVT)**：
    
    - 存放所有中断向量的一张表，通常放在内存的**最低端**（如 0000H 开始）。
        
    - _比喻_：这是小区的“住户名录墙”。
        
3. **向量地址 (Vector Address)**：
    
    - 访问中断向量表的**指针**。
        
    - _比喻_：这是名录墙上的“行号”。
        

关系链：

中断类型码 $\xrightarrow{\times 4}$ 向量地址 $\xrightarrow{\text{查表}}$ 中断向量 $\xrightarrow{\text{跳转}}$ 服务程序

---

### 三、中断向量表的组成 (Structure of IVT)

课件以 **IBM PC** 和 **模型机** 为例展示了表的结构。

- **存储位置**：主存的最低端（0~1023 号单元，共 1KB）。
    
- **表项大小**：每个中断源占用 **4 个字节**。
    
    - 这 4 个字节存的是：2 字节的段内偏移地址 (IP) + 2 字节的段基址 (CS)。
        
- **容量**：$1024 \text{字节} / 4 \text{字节} = 256$ 个中断源。
    

**分区（了解即可）**：

- **专用区** (0-4号)：专门留给系统极其重要的错误（如除法错）。
    
- **保留区** (5-31号)：留给未来扩展。
    
- **用户区** (32-255号)：给外部设备（如键盘、打印机）和软中断使用。
    

---

### 四、地址的计算与获取 (Calculation) —— **⭐ 必考计算**

硬件是如何通过一个简单的“中断号”找到入口地址的？

- 公式：
    
    $$\text{向量地址} = \text{中断类型码} \times 4$$
    
    - _为什么乘 4？_ 因为表里每一项占 4 个字节。
        
- **举例（课件 P30）**：
    
    - 题目：中断类型码为 **108**。
        
    - 计算：$108 \times 4 = 432$。
        
    - 换算十六进制：$432 = 1B0H$。
        
    - **结论**：CPU 会去内存地址 **001B0H** 处读取 4 个字节，这 4 个字节里的内容就是服务程序的入口地址。
        

---

### 五、中断响应的硬件过程 (Hardware Response Process)

这是 **IT (中断周期)** 内硬件自动完成的一系列动作，**不需要程序员写代码**。

1. **发响应信号**：CPU 发出 `INTA`，告诉 8259A “我准备好了”。
    
2. **关中断**：硬件自动置 `IF=0`，防止处理过程中被别的新中断打扰。
    
3. **保护断点**：硬件自动把 **PSW（标志寄存器）**、**CS（代码段）**、**PC（指令指针）** 压入堆栈保存。
    
4. **获取类型码**：从数据总线上读取由 8259A 送来的中断类型码。
    
5. **查表跳转**：
    
    - 硬件将类型码 $\times 4$，算出向量地址。
        
    - 访问内存（向量表），取出入口地址送入 PC 和 CS。
        
    - **下一条指令，CPU 就已经在执行中断服务程序了！**
        

---

### 🧠 总结

复习这一节，你只需要记住**“查表”**的逻辑：

1. **谁给号？** 接口（8259A）给 CPU 一个**中断类型码**。
    
2. **去哪查？** 内存最低端的**中断向量表**。
    
3. **查哪个？** 类型码 **乘以 4** 的位置。
    
4. **得到啥？** 得到**入口地址**（CS:IP），直接覆盖 PC，完成跳转。
    

至此，硬件（CPU）已经成功把控制权交给了软件（服务程序）。下一节 **5.4.5 中断处理** 将讲解软件接手后要做什么（保护现场、服务、恢复现场）。


# 5. 中断处理

主要讲述当 CPU 找到了服务程序入口并跳转过去之后，软件层面具体要按照什么步骤来执行。

#### 1. 两种处理模式 (Two Modes)

根据“在处理一个中断时，是否允许被另一个更高级的中断打断”，分为两种模式：

- **单级中断 (Single-level)**：
    
    - **特点**：**“一心一意”**。CPU 一旦响应了一个中断，就自动关闭中断（关大门），处理完这一个再开门。期间谁来也不理 。
        
- **多重中断 (Nested/Multi-level)**：
    
    - **特点**：**“更重要的先来”**。在处理低级中断时，如果来了高级中断，CPU 会暂停手头的活，先去处理高级的（中断嵌套） 。
        

#### 2. 标准处理流程 (Standard Workflow) —— **⭐ 必考流程图**

这是编写中断服务程序（ISR）的标准模板，分为 **4 个阶段**（以多重中断为例，见 P40, P42）：

1. **保护现场 (Save Context)**：
    
    - **动作**：将通用寄存器、状态寄存器里的内容压入堆栈。
        
    - _目的_：为了防止服务程序用到这些寄存器，把主程序的数据覆盖了。
        
    - _状态_：此时必须是**关中断**的，保护过程不能被打扰。
        
2. **开中断 (Enable Interrupts)** —— **多重中断的关键**：
    
    - **动作**：执行 `STI` 指令。
        
    - _目的_：打开大门，允许更高级的中断插队。如果是单级中断，就没有这一步。
        
3. **执行具体服务 (Service Execution)**：
    
    - **动作**：做真正的业务逻辑（比如从端口读数据、把数据送去打印）。
        
4. **恢复现场与返回 (Restore & Return)**：
    
    - **动作**：
        
        1. **关中断** (`CLI`)：恢复现场是原子操作，不能被打断。
            
        2. **恢复现场**：把堆栈里的数据弹回到寄存器 (`POP`)。
            
        3. **中断返回**：执行 `IRET` 指令。这不仅是跳转，还会自动恢复 `PC` 和 `PSW`（开中断）。


# 6. 中断接口



展示了支持上述功能的硬件电路结构。

#### 1. 接口的通用组成 (Components)

请看 **PPT P43** 的框图，一个标准的中断接口板包含以下部分：

- **寄存器组**：
    
    - **命令字寄存器 (Write)**：CPU 写命令进来（如“启动设备”）。
        
    - **状态字寄存器 (Read)**：CPU 读状态出去（如“忙”、“出错”）。
        
    - **数据缓冲寄存器 (Buffer)**：暂存数据，匹配速度 。
        
- **控制逻辑**：
    
    - 负责产生 `IREQ`（中断请求）信号。
        
    - 负责电平转换、串并转换。
        
- **中断控制器 (如 8259A)**：
    
    - 这是接口板的“大脑”，负责判优、屏蔽，并向 CPU 发送最终的 `INT` 信号和类型码 。
        

#### 2. 完整的工作过程 (Workflow)

这是一个软硬结合的接力赛（P45）：

1. **CPU 初始化**：设置 8259A 的屏蔽字，准备好向量表 。
    
2. **启动**：CPU 写“启动命令”到接口。
    
3. **请求**：外设干完活了，接口逻辑发出 `IREQ` 给 8259A。
    
4. **判优与通知**：8259A 判断没被屏蔽且优先级够高，向 CPU 发 `INT`。
    
5. **响应**：CPU 发 `INTA`，8259A 把**中断类型码**放到数据线上 。
    
6. **服务**：CPU 拿到号，查表，跳转执行服务程序。



# 07