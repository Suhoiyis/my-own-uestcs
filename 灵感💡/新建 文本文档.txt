1、一个自定义16位RISC CPU的ISA设计。自定义16位RISC CPU的内容包括两方面：
（一）16个16位通用寄存器，r0-r15
（二）16条指令及其格式：
a）跳转 jal rd, imm ；jalr rd,rs1,imm 
b）加载高位立即数 lui rd, imm
c）分支beq,ble op rs1,rs2,offset
d）访存lb,lw  op rd,offset(rs1)；sb,sw op rs2,offset(rs1)。
e）算数和逻辑运算
add,sub,and,or op rd,rs1,rs2；
addi,subi           op rd,rs1, imm

2、一条CPU的指令执行分为取指、译码、执行、访存和写回5个阶段。取指阶段的功能部件：PC地址生成器、指令存储器、IR寄存器；译码阶段的功能部件：通用寄存器堆、立即数扩展、控制单元；执行阶段的功能部件：算术逻辑运算单元ALU、ALU操作数选择器；访存阶段的功能部件：数据存储器；写回阶段的功能部件：写回选择器、通用寄存器堆。各个阶段功能部件的实现可以先易后难，即先使用Python或C语言在主机上完成，然后再使用Verilog语言在FPGA上完成。

3、按一个时钟周期执行一条指令，将上述的功能部件（除数据存储器和指令存储器）有机地连接起来，以构成一个完整的单周期CPU。再将CPU与数据存储器和指令存储器有机地连接起来，形成一个最简单(具有基本功能)计算机系统。亦可使用Python或C语言在主机上完成，或使用Verilog语言在FPGA上完成。

4、给定一个汇编程序，制定汇编语法规则，写一个软件将汇编指令翻译成机器指令。再根据汇编语法规则，写一个整数排序程序。
5、编写一个汇编程序可视化开发工具，能够编辑、编译和下载执行（包含主机Client和目标机Server两个部分，使用UART串口通信，能够动态地将机器指令下载到目标机上执行）。


微指令



1、一个自定义16位RISC CPU的ISA设计。自定义16位RISC CPU的内容包括两方面：
（一）16个16位通用寄存器，r0-r15
（二）16条指令及其格式：
a）跳转 jal rd, imm ；jalr rd,rs1,imm 
b）加载高位立即数 lui rd, imm
c）分支beq,ble op rs1,rs2,offset
d）访存lb,lw  op rd,offset(rs1)；sb,sw op rs2,offset(rs1)。
e）算数和逻辑运算
add,sub,and,or op rd,rs1,rs2；
addi,subi           op rd,rs1, imm

16个16位通用寄存器：r0-r15，其中r0为恒0寄存器，r1为返回地址寄存器ra，r2为栈指针寄存器sp，其余为运算寄存器a0-a12(即r3-r15)，其中a0还作为保存函数参数或返回值。

写具体含义和机器码
（机器码顺序：偏移量_目的操作数_源操作数_操作指令）



 
 
#目的：认识指令的具体含义并尝试自己写出对应的机器码
#机器码顺序：偏移量（imm/offset）_目的操作数_源操作数_操作指令

0.jal rd,imm：
'''
#  将PC的值加上2，结果写入rd寄存器，rd默认为r1，同时将PC的值设置为PC加上符号位拓展的
imm，即PC=PC+sext(imm)。
 
#小端模式，small endian mode
0000 0100(imm) 0001(rd) 0000(jal)
机器码：16’b0000_0100_0001_0000

 '''
1.jalr rd,rs1,imm：
'''
#将PC的值加上2，结果写入rd寄存器，rd默认为r1，同时将PC值设置为寄存器rs1的值加上符号位拓展的imm，即PC=rs1+sext(imm)。
# 0100(imm) 0011(rs1) 0001(rd) 0001(jalr)
# 机器码：16’b0100_0011_0001_0001
'''

2.beq rs1,rs2,offset
'''
如果寄存器rs1(a1:0100)和rs2(a2:0101)的值相等，那么跳转，偏移量为offset(6),否则执行下一条(pc = pc + 2)
举例：
if a1 == a2:
PC = PC + 6
else:
pc = pc + 2
'''
机器码：16'b 0110_0101_0100_0010

3.ble rd, rs2, offset
'''
如果寄存器rs1(a1)的值小于等于rs2(a2)的值，则跳转，偏移量为offset(6),否则执行下一条(pc= pc + 2)
举例：
if a1 <= a2:
PC = pc + 6
else:
pc = pc + 2
'''
机器码： 16'b0110_0101_0100_0011

4.lb rd, offset(rs1)
'''
从寄存器rs1中获得基础地址(a1:0100)，a1加上偏移量offset(6)后得到内存地址，然后将内存地址存放的一字节数据加载到寄存器rd(a2)中
举例:
ad = a1 + 6
a2 = (ad)
'''
机器码：16'b0110_0101_0100_0100

5.lw rd, offset(rs1)
'''
从寄存器rs1中获得基础地址(a1:0100)，a1加上偏移量offset(6)后得到内存地址，然后将内存地址存放的一个字（2字节）数据加载到寄存器rd(a2)中
举例:
ad = a1 + 6
a2 = (ad)
'''

机器码：16'b0110_0101_0100_0101

6.sb rs1, offset(rs2)
'''
从寄存器rs2(a2)中获得基址，a2加上偏移量offset(6)后得到内存地址，然后将寄存器rs1(a1:0100)中存放的一字节数据存放到内存地址中
举例:
ad = a2 + 6
(ad) = a1
'''
机器码：16'b0110_0101_0100_0110

7.sw rs1, offset(rs2)
'''
从寄存器rs2(a2)中获得基址，a2加上偏移量offset(6)后得到内存地址，然后将寄存器rs1(a1:0100)中存放的一个字（2字节）数据存放到内存地址中
举例:
ad = a2 + 6
(ad) = a1
'''
机器码：16'b0110_0101_0100_0111

8.add rd,rs1,rs2
'''
将寄存器rs1(r0)和rs2(r1)中的值相加，然后存放到rd(r2)中
add r2, r0, r1
举例：
r2 = r0 + r1
'''
机器码：16'b0010_0001_0000_1000

9.sub rd,rs1,rs2
'''
将寄存器rs1(r0)和rs2(r1)中的值相减，然后存放到rd(r2)中sub r2, r0, r1
举例：
r2 = r0 - r1
'''
机器码：16'b0010_0001_0000_1001


10.and rd,rs1,rs2
'''
将寄存器rs1(r0)和rs2(r1)进行逻辑并运算，然后将结果存放到rd(r2)中and r2, r0, r1
举例：
r2 = r0 & r1
'''
机器码：16'b0010_0001_0000_1010

11.or rd,rs1,rs2
'''
将寄存器rs1(r0)和rs2(r1)进行逻辑或运算，然后将结果存放到rd(r2)中
or r2, r0, r1
举例：
r2 = r0 | r1
 机器码：16'b0010_0001_0000_1011


12.	addi rd,rs1,imm '''
将寄存器rs1(r0)和imm(6)中的值相加，然后存放到rd(r1)中
举例：
r2 = r0 + 6 '''
机器码：16'b0110_0001_0000_1100


13.	subi rd,rs1,imm '''
将寄存器rs1(r0)的值和imm(6)相减，然后存放到rd(r2)中
举例：
r2 = r0 - 6 '''
机器码：16'b0110_0010_0000_1101



14.	andi rd,rs1,imm '''
将寄存器rs1(r0)和imm(6)进行逻辑并运算，然后将结果存放到rd(r2)中
举例：
r2 = r0 & imm '''
机器码：16'b0110_0010_0000_1110


15.	ori rd,rs1,imm '''
将寄存器rs1(r0)和imm(6)进行逻辑或运算，然后将结果存放到rd(r2)中
举例：
r2 = r0 | 6 '''
机器码：16'b0110_0010_0000_1111

 
 这是我之前写的16条指令含义及其机器码，但是现在去除了其中的andi与ori，增加了lui，在不改变其他14条指令的基础上，仿照这个格式写出现在15条指令的含义与机器码

// jal->addi->subi->beq->jalr->ble->add->sub->sb->sw->lb->lw->and->or->andi->ori
    0000_0100_0001_0000 
  //  imm(4),   rd,  jal    (r1) = pc + 2, pc = pc + 4  //此时(r1) = 2, pc =4

    0110_0011_0001_0001     (r1) = pc + 2, pc = (r3) + 6  //此时(r1) = 4, pc = 10
  //imm,  rs,  rd,  jalr

    0010_0001_0011_1100     
  //imm   rs,  rd,  addi    (r3) = (r1) + 2     // 此时(r3) = 4, pc = 6

    1110_0001_0100_1101
  //imm,  rs,  rd,  subi    (r4) = (r1) - (-2)   //此时(r4) = 4, pc = 8

    0100_0011_1010_0010     (r3) == (r4) ? pc = pc - 6 : pc = pc + 2  //此时pc = 2
  //rt,  rs, offset, beq
    
    0101_0011_0000_0011
  //rt,  rs, offset, ble    (r3) <= (r5) ? pc = pc  : pc = pc + 2     // pc = 12
    
    0100_0011_0101_1000
  //rt,   rs,  rd,  add    (r5) = (r3) + (r4)   //此时(r5) = 8
    
    0100_0011_0110_1001
  //rt,   rs,  rd,  sub    (r6) = (r3) - (r4)   //此时(r6) = 0

    0101_0110_0010_0110
  //rt,  rs,  imm,  sb      ad = (r6) + 2   (ad) = (r5)     //此时存储单元[2] = 8

    0101_0110_0100_0111
  //rt,  rs,  imm,  sw      ad = (r6) + 4   (ad) = (r5)     //此时存储单元[4] = 8   存储单元[5] = 0    

    0100_0110_0111_0100
  //imm,  rs,  rd,  lb      ad = (r6) + 4   (r7) = (ad)     //此时(r7) = 0000_1000

    0010_0110_1000_0101
  //imm,  rs,  rd,  lw      ad = (r6) + 2   (r8) = (ad)     //此时(r8) = 0000_1000_0000_0000

    0110_0101_1001_1010
  //rt,   rs,  rd,  and    (r9) = (r5) && (r6)  //此时r9 = 0

    0110_0101_1010_1011
  //rt,   rs,  rd,  or     (r10) = (r5) || (r6)  //此时r10 = 8 即(0000_0000_0000_1000)

    1010_0001_1011_1110
  //    imm,    rd,  lui      (r11) = imm << 8  //此时r11 = 1010_0001_0000_0000


/*操作码
jal 0000 
jalr 0001
beq 0010
ble 0011
lb  0100
lw  0101
sb  0110
sw  0111
add 1000
sub 1001
and 1010
or  1011
lui 1110
