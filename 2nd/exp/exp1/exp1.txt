1. 	a:0x64
	b:0x64
	c:0x42c80000
	d:0x4059000000000000



2.	int a
从结构体的起始位置（偏移量0）开始存储

long b
 a 结束后，内存地址为偏移量4。因为4不是long类型大小（8字节）的整数倍，所以编译器会在a和b之间填充4个字节的空洞，使b的起始地址变为偏移量8

float c
 b 结束后，内存地址为偏移量16。因为16是float类型大小（4字节）的整数倍，所以c可以直接存储在偏移量16处

double d
 c 结束后，内存地址为偏移量20。因为20不是double类型大小（8字节）的整数倍，所以编译器会在c和d之间再次填充4个字节的空洞，使d的起始地址变为偏移量24

整个结构体的总大小也必须是其内部最大对齐成员（long或double，都是8字节）的整数倍。成员d结束后地址为24 + 8 = 32。32是8的整数倍
单个struct record占用的总字节数是 32字节

程序中定义的数组为 struct record R[2]，包含2个struct record元素。
32 字节/个×2 个=64 字节



3.	120000690:	03b7bd8c 	ori	$r12,$r12,0xdef

10到21位



4.	R[0].a+R[1].a的输出值是-2147483556：因为发生了溢出
	32位int最大值为（2的31次方-1）2147483647
	R[0].a=100	R[1].a=2147483640		R[0].a+R[1].a=2147483740>2147483647

	R[1].c=16777216	R[1].d=16777217
	然而题目中赋值是16777217
	R[1].c是float型单精度变量，能精确表示的最大数是（2的24次方）16777216
	当赋值是16777217时超出最大范围，舍入到最近的标示值（16777216）
	R[1].d是double型双精度变量，表示范围更大，可以准确存储16777217这个数



5.	应当尽量减少a b c d四个变量间的空洞
	之前的一个数组R占用的总字节数是 32字节，但是有8个字节的空洞

	只调整a b c d四个顺序即可解决（d b a c）
